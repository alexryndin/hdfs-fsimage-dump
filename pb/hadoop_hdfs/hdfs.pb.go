// Code generated by protoc-gen-gogo.
// source: hdfs.proto
// DO NOT EDIT!

package hadoop_hdfs

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import hadoop_common "../hadoop_common"

import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// *
// Types of recognized storage media.
type StorageTypeProto int32

const (
	StorageTypeProto_DISK StorageTypeProto = 1
	StorageTypeProto_SSD  StorageTypeProto = 2
)

var StorageTypeProto_name = map[int32]string{
	1: "DISK",
	2: "SSD",
}
var StorageTypeProto_value = map[string]int32{
	"DISK": 1,
	"SSD":  2,
}

func (x StorageTypeProto) Enum() *StorageTypeProto {
	p := new(StorageTypeProto)
	*p = x
	return p
}
func (x StorageTypeProto) String() string {
	return proto.EnumName(StorageTypeProto_name, int32(x))
}
func (x *StorageTypeProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StorageTypeProto_value, data, "StorageTypeProto")
	if err != nil {
		return err
	}
	*x = StorageTypeProto(value)
	return nil
}
func (StorageTypeProto) EnumDescriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{0} }

// *
// Cipher suite.
type CipherSuiteProto int32

const (
	CipherSuiteProto_UNKNOWN           CipherSuiteProto = 1
	CipherSuiteProto_AES_CTR_NOPADDING CipherSuiteProto = 2
)

var CipherSuiteProto_name = map[int32]string{
	1: "UNKNOWN",
	2: "AES_CTR_NOPADDING",
}
var CipherSuiteProto_value = map[string]int32{
	"UNKNOWN":           1,
	"AES_CTR_NOPADDING": 2,
}

func (x CipherSuiteProto) Enum() *CipherSuiteProto {
	p := new(CipherSuiteProto)
	*p = x
	return p
}
func (x CipherSuiteProto) String() string {
	return proto.EnumName(CipherSuiteProto_name, int32(x))
}
func (x *CipherSuiteProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CipherSuiteProto_value, data, "CipherSuiteProto")
	if err != nil {
		return err
	}
	*x = CipherSuiteProto(value)
	return nil
}
func (CipherSuiteProto) EnumDescriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{1} }

// *
// Crypto protocol version used to access encrypted files.
type CryptoProtocolVersionProto int32

const (
	CryptoProtocolVersionProto_UNKNOWN_PROTOCOL_VERSION CryptoProtocolVersionProto = 1
	CryptoProtocolVersionProto_ENCRYPTION_ZONES         CryptoProtocolVersionProto = 2
)

var CryptoProtocolVersionProto_name = map[int32]string{
	1: "UNKNOWN_PROTOCOL_VERSION",
	2: "ENCRYPTION_ZONES",
}
var CryptoProtocolVersionProto_value = map[string]int32{
	"UNKNOWN_PROTOCOL_VERSION": 1,
	"ENCRYPTION_ZONES":         2,
}

func (x CryptoProtocolVersionProto) Enum() *CryptoProtocolVersionProto {
	p := new(CryptoProtocolVersionProto)
	*p = x
	return p
}
func (x CryptoProtocolVersionProto) String() string {
	return proto.EnumName(CryptoProtocolVersionProto_name, int32(x))
}
func (x *CryptoProtocolVersionProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoProtocolVersionProto_value, data, "CryptoProtocolVersionProto")
	if err != nil {
		return err
	}
	*x = CryptoProtocolVersionProto(value)
	return nil
}
func (CryptoProtocolVersionProto) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorHdfs, []int{2}
}

// *
// Checksum algorithms/types used in HDFS
// Make sure this enum's integer values match enum values' id properties defined
// in org.apache.hadoop.util.DataChecksum.Type
type ChecksumTypeProto int32

const (
	ChecksumTypeProto_CHECKSUM_NULL   ChecksumTypeProto = 0
	ChecksumTypeProto_CHECKSUM_CRC32  ChecksumTypeProto = 1
	ChecksumTypeProto_CHECKSUM_CRC32C ChecksumTypeProto = 2
)

var ChecksumTypeProto_name = map[int32]string{
	0: "CHECKSUM_NULL",
	1: "CHECKSUM_CRC32",
	2: "CHECKSUM_CRC32C",
}
var ChecksumTypeProto_value = map[string]int32{
	"CHECKSUM_NULL":   0,
	"CHECKSUM_CRC32":  1,
	"CHECKSUM_CRC32C": 2,
}

func (x ChecksumTypeProto) Enum() *ChecksumTypeProto {
	p := new(ChecksumTypeProto)
	*p = x
	return p
}
func (x ChecksumTypeProto) String() string {
	return proto.EnumName(ChecksumTypeProto_name, int32(x))
}
func (x *ChecksumTypeProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ChecksumTypeProto_value, data, "ChecksumTypeProto")
	if err != nil {
		return err
	}
	*x = ChecksumTypeProto(value)
	return nil
}
func (ChecksumTypeProto) EnumDescriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{3} }

// *
// State of a block replica at a datanode
type ReplicaStateProto int32

const (
	ReplicaStateProto_FINALIZED ReplicaStateProto = 0
	ReplicaStateProto_RBW       ReplicaStateProto = 1
	ReplicaStateProto_RWR       ReplicaStateProto = 2
	ReplicaStateProto_RUR       ReplicaStateProto = 3
	ReplicaStateProto_TEMPORARY ReplicaStateProto = 4
)

var ReplicaStateProto_name = map[int32]string{
	0: "FINALIZED",
	1: "RBW",
	2: "RWR",
	3: "RUR",
	4: "TEMPORARY",
}
var ReplicaStateProto_value = map[string]int32{
	"FINALIZED": 0,
	"RBW":       1,
	"RWR":       2,
	"RUR":       3,
	"TEMPORARY": 4,
}

func (x ReplicaStateProto) Enum() *ReplicaStateProto {
	p := new(ReplicaStateProto)
	*p = x
	return p
}
func (x ReplicaStateProto) String() string {
	return proto.EnumName(ReplicaStateProto_name, int32(x))
}
func (x *ReplicaStateProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ReplicaStateProto_value, data, "ReplicaStateProto")
	if err != nil {
		return err
	}
	*x = ReplicaStateProto(value)
	return nil
}
func (ReplicaStateProto) EnumDescriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{4} }

type DatanodeInfoProto_AdminState int32

const (
	DatanodeInfoProto_NORMAL                  DatanodeInfoProto_AdminState = 0
	DatanodeInfoProto_DECOMMISSION_INPROGRESS DatanodeInfoProto_AdminState = 1
	DatanodeInfoProto_DECOMMISSIONED          DatanodeInfoProto_AdminState = 2
)

var DatanodeInfoProto_AdminState_name = map[int32]string{
	0: "NORMAL",
	1: "DECOMMISSION_INPROGRESS",
	2: "DECOMMISSIONED",
}
var DatanodeInfoProto_AdminState_value = map[string]int32{
	"NORMAL":                  0,
	"DECOMMISSION_INPROGRESS": 1,
	"DECOMMISSIONED":          2,
}

func (x DatanodeInfoProto_AdminState) Enum() *DatanodeInfoProto_AdminState {
	p := new(DatanodeInfoProto_AdminState)
	*p = x
	return p
}
func (x DatanodeInfoProto_AdminState) String() string {
	return proto.EnumName(DatanodeInfoProto_AdminState_name, int32(x))
}
func (x *DatanodeInfoProto_AdminState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DatanodeInfoProto_AdminState_value, data, "DatanodeInfoProto_AdminState")
	if err != nil {
		return err
	}
	*x = DatanodeInfoProto_AdminState(value)
	return nil
}
func (DatanodeInfoProto_AdminState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorHdfs, []int{4, 0}
}

type DatanodeStorageProto_StorageState int32

const (
	DatanodeStorageProto_NORMAL           DatanodeStorageProto_StorageState = 0
	DatanodeStorageProto_READ_ONLY_SHARED DatanodeStorageProto_StorageState = 1
)

var DatanodeStorageProto_StorageState_name = map[int32]string{
	0: "NORMAL",
	1: "READ_ONLY_SHARED",
}
var DatanodeStorageProto_StorageState_value = map[string]int32{
	"NORMAL":           0,
	"READ_ONLY_SHARED": 1,
}

func (x DatanodeStorageProto_StorageState) Enum() *DatanodeStorageProto_StorageState {
	p := new(DatanodeStorageProto_StorageState)
	*p = x
	return p
}
func (x DatanodeStorageProto_StorageState) String() string {
	return proto.EnumName(DatanodeStorageProto_StorageState_name, int32(x))
}
func (x *DatanodeStorageProto_StorageState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DatanodeStorageProto_StorageState_value, data, "DatanodeStorageProto_StorageState")
	if err != nil {
		return err
	}
	*x = DatanodeStorageProto_StorageState(value)
	return nil
}
func (DatanodeStorageProto_StorageState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorHdfs, []int{5, 0}
}

type HdfsFileStatusProto_FileType int32

const (
	HdfsFileStatusProto_IS_DIR     HdfsFileStatusProto_FileType = 1
	HdfsFileStatusProto_IS_FILE    HdfsFileStatusProto_FileType = 2
	HdfsFileStatusProto_IS_SYMLINK HdfsFileStatusProto_FileType = 3
)

var HdfsFileStatusProto_FileType_name = map[int32]string{
	1: "IS_DIR",
	2: "IS_FILE",
	3: "IS_SYMLINK",
}
var HdfsFileStatusProto_FileType_value = map[string]int32{
	"IS_DIR":     1,
	"IS_FILE":    2,
	"IS_SYMLINK": 3,
}

func (x HdfsFileStatusProto_FileType) Enum() *HdfsFileStatusProto_FileType {
	p := new(HdfsFileStatusProto_FileType)
	*p = x
	return p
}
func (x HdfsFileStatusProto_FileType) String() string {
	return proto.EnumName(HdfsFileStatusProto_FileType_name, int32(x))
}
func (x *HdfsFileStatusProto_FileType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HdfsFileStatusProto_FileType_value, data, "HdfsFileStatusProto_FileType")
	if err != nil {
		return err
	}
	*x = HdfsFileStatusProto_FileType(value)
	return nil
}
func (HdfsFileStatusProto_FileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorHdfs, []int{18, 0}
}

type NamenodeRegistrationProto_NamenodeRoleProto int32

const (
	NamenodeRegistrationProto_NAMENODE   NamenodeRegistrationProto_NamenodeRoleProto = 1
	NamenodeRegistrationProto_BACKUP     NamenodeRegistrationProto_NamenodeRoleProto = 2
	NamenodeRegistrationProto_CHECKPOINT NamenodeRegistrationProto_NamenodeRoleProto = 3
)

var NamenodeRegistrationProto_NamenodeRoleProto_name = map[int32]string{
	1: "NAMENODE",
	2: "BACKUP",
	3: "CHECKPOINT",
}
var NamenodeRegistrationProto_NamenodeRoleProto_value = map[string]int32{
	"NAMENODE":   1,
	"BACKUP":     2,
	"CHECKPOINT": 3,
}

func (x NamenodeRegistrationProto_NamenodeRoleProto) Enum() *NamenodeRegistrationProto_NamenodeRoleProto {
	p := new(NamenodeRegistrationProto_NamenodeRoleProto)
	*p = x
	return p
}
func (x NamenodeRegistrationProto_NamenodeRoleProto) String() string {
	return proto.EnumName(NamenodeRegistrationProto_NamenodeRoleProto_name, int32(x))
}
func (x *NamenodeRegistrationProto_NamenodeRoleProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NamenodeRegistrationProto_NamenodeRoleProto_value, data, "NamenodeRegistrationProto_NamenodeRoleProto")
	if err != nil {
		return err
	}
	*x = NamenodeRegistrationProto_NamenodeRoleProto(value)
	return nil
}
func (NamenodeRegistrationProto_NamenodeRoleProto) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorHdfs, []int{26, 0}
}

type NamenodeCommandProto_Type int32

const (
	NamenodeCommandProto_NamenodeCommand   NamenodeCommandProto_Type = 0
	NamenodeCommandProto_CheckPointCommand NamenodeCommandProto_Type = 1
)

var NamenodeCommandProto_Type_name = map[int32]string{
	0: "NamenodeCommand",
	1: "CheckPointCommand",
}
var NamenodeCommandProto_Type_value = map[string]int32{
	"NamenodeCommand":   0,
	"CheckPointCommand": 1,
}

func (x NamenodeCommandProto_Type) Enum() *NamenodeCommandProto_Type {
	p := new(NamenodeCommandProto_Type)
	*p = x
	return p
}
func (x NamenodeCommandProto_Type) String() string {
	return proto.EnumName(NamenodeCommandProto_Type_name, int32(x))
}
func (x *NamenodeCommandProto_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(NamenodeCommandProto_Type_value, data, "NamenodeCommandProto_Type")
	if err != nil {
		return err
	}
	*x = NamenodeCommandProto_Type(value)
	return nil
}
func (NamenodeCommandProto_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorHdfs, []int{28, 0}
}

// *
// Extended block idenfies a block
type ExtendedBlockProto struct {
	PoolId           *string `protobuf:"bytes,1,req,name=poolId" json:"poolId,omitempty"`
	BlockId          *uint64 `protobuf:"varint,2,req,name=blockId" json:"blockId,omitempty"`
	GenerationStamp  *uint64 `protobuf:"varint,3,req,name=generationStamp" json:"generationStamp,omitempty"`
	NumBytes         *uint64 `protobuf:"varint,4,opt,name=numBytes,def=0" json:"numBytes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ExtendedBlockProto) Reset()                    { *m = ExtendedBlockProto{} }
func (m *ExtendedBlockProto) String() string            { return proto.CompactTextString(m) }
func (*ExtendedBlockProto) ProtoMessage()               {}
func (*ExtendedBlockProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{0} }

const Default_ExtendedBlockProto_NumBytes uint64 = 0

func (m *ExtendedBlockProto) GetPoolId() string {
	if m != nil && m.PoolId != nil {
		return *m.PoolId
	}
	return ""
}

func (m *ExtendedBlockProto) GetBlockId() uint64 {
	if m != nil && m.BlockId != nil {
		return *m.BlockId
	}
	return 0
}

func (m *ExtendedBlockProto) GetGenerationStamp() uint64 {
	if m != nil && m.GenerationStamp != nil {
		return *m.GenerationStamp
	}
	return 0
}

func (m *ExtendedBlockProto) GetNumBytes() uint64 {
	if m != nil && m.NumBytes != nil {
		return *m.NumBytes
	}
	return Default_ExtendedBlockProto_NumBytes
}

// *
// Identifies a Datanode
type DatanodeIDProto struct {
	IpAddr       *string `protobuf:"bytes,1,req,name=ipAddr" json:"ipAddr,omitempty"`
	HostName     *string `protobuf:"bytes,2,req,name=hostName" json:"hostName,omitempty"`
	DatanodeUuid *string `protobuf:"bytes,3,req,name=datanodeUuid" json:"datanodeUuid,omitempty"`
	// upgraded clusters this is the same
	// as the original StorageID of the
	// Datanode.
	XferPort         *uint32 `protobuf:"varint,4,req,name=xferPort" json:"xferPort,omitempty"`
	InfoPort         *uint32 `protobuf:"varint,5,req,name=infoPort" json:"infoPort,omitempty"`
	IpcPort          *uint32 `protobuf:"varint,6,req,name=ipcPort" json:"ipcPort,omitempty"`
	InfoSecurePort   *uint32 `protobuf:"varint,7,opt,name=infoSecurePort,def=0" json:"infoSecurePort,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatanodeIDProto) Reset()                    { *m = DatanodeIDProto{} }
func (m *DatanodeIDProto) String() string            { return proto.CompactTextString(m) }
func (*DatanodeIDProto) ProtoMessage()               {}
func (*DatanodeIDProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{1} }

const Default_DatanodeIDProto_InfoSecurePort uint32 = 0

func (m *DatanodeIDProto) GetIpAddr() string {
	if m != nil && m.IpAddr != nil {
		return *m.IpAddr
	}
	return ""
}

func (m *DatanodeIDProto) GetHostName() string {
	if m != nil && m.HostName != nil {
		return *m.HostName
	}
	return ""
}

func (m *DatanodeIDProto) GetDatanodeUuid() string {
	if m != nil && m.DatanodeUuid != nil {
		return *m.DatanodeUuid
	}
	return ""
}

func (m *DatanodeIDProto) GetXferPort() uint32 {
	if m != nil && m.XferPort != nil {
		return *m.XferPort
	}
	return 0
}

func (m *DatanodeIDProto) GetInfoPort() uint32 {
	if m != nil && m.InfoPort != nil {
		return *m.InfoPort
	}
	return 0
}

func (m *DatanodeIDProto) GetIpcPort() uint32 {
	if m != nil && m.IpcPort != nil {
		return *m.IpcPort
	}
	return 0
}

func (m *DatanodeIDProto) GetInfoSecurePort() uint32 {
	if m != nil && m.InfoSecurePort != nil {
		return *m.InfoSecurePort
	}
	return Default_DatanodeIDProto_InfoSecurePort
}

// *
// Datanode local information
type DatanodeLocalInfoProto struct {
	SoftwareVersion  *string `protobuf:"bytes,1,req,name=softwareVersion" json:"softwareVersion,omitempty"`
	ConfigVersion    *string `protobuf:"bytes,2,req,name=configVersion" json:"configVersion,omitempty"`
	Uptime           *uint64 `protobuf:"varint,3,req,name=uptime" json:"uptime,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatanodeLocalInfoProto) Reset()                    { *m = DatanodeLocalInfoProto{} }
func (m *DatanodeLocalInfoProto) String() string            { return proto.CompactTextString(m) }
func (*DatanodeLocalInfoProto) ProtoMessage()               {}
func (*DatanodeLocalInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{2} }

func (m *DatanodeLocalInfoProto) GetSoftwareVersion() string {
	if m != nil && m.SoftwareVersion != nil {
		return *m.SoftwareVersion
	}
	return ""
}

func (m *DatanodeLocalInfoProto) GetConfigVersion() string {
	if m != nil && m.ConfigVersion != nil {
		return *m.ConfigVersion
	}
	return ""
}

func (m *DatanodeLocalInfoProto) GetUptime() uint64 {
	if m != nil && m.Uptime != nil {
		return *m.Uptime
	}
	return 0
}

// *
// DatanodeInfo array
type DatanodeInfosProto struct {
	Datanodes        []*DatanodeInfoProto `protobuf:"bytes,1,rep,name=datanodes" json:"datanodes,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *DatanodeInfosProto) Reset()                    { *m = DatanodeInfosProto{} }
func (m *DatanodeInfosProto) String() string            { return proto.CompactTextString(m) }
func (*DatanodeInfosProto) ProtoMessage()               {}
func (*DatanodeInfosProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{3} }

func (m *DatanodeInfosProto) GetDatanodes() []*DatanodeInfoProto {
	if m != nil {
		return m.Datanodes
	}
	return nil
}

// *
// The status of a Datanode
type DatanodeInfoProto struct {
	Id               *DatanodeIDProto              `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Capacity         *uint64                       `protobuf:"varint,2,opt,name=capacity,def=0" json:"capacity,omitempty"`
	DfsUsed          *uint64                       `protobuf:"varint,3,opt,name=dfsUsed,def=0" json:"dfsUsed,omitempty"`
	Remaining        *uint64                       `protobuf:"varint,4,opt,name=remaining,def=0" json:"remaining,omitempty"`
	BlockPoolUsed    *uint64                       `protobuf:"varint,5,opt,name=blockPoolUsed,def=0" json:"blockPoolUsed,omitempty"`
	LastUpdate       *uint64                       `protobuf:"varint,6,opt,name=lastUpdate,def=0" json:"lastUpdate,omitempty"`
	XceiverCount     *uint32                       `protobuf:"varint,7,opt,name=xceiverCount,def=0" json:"xceiverCount,omitempty"`
	Location         *string                       `protobuf:"bytes,8,opt,name=location" json:"location,omitempty"`
	AdminState       *DatanodeInfoProto_AdminState `protobuf:"varint,10,opt,name=adminState,enum=hadoop.hdfs.DatanodeInfoProto_AdminState,def=0" json:"adminState,omitempty"`
	CacheCapacity    *uint64                       `protobuf:"varint,11,opt,name=cacheCapacity,def=0" json:"cacheCapacity,omitempty"`
	CacheUsed        *uint64                       `protobuf:"varint,12,opt,name=cacheUsed,def=0" json:"cacheUsed,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *DatanodeInfoProto) Reset()                    { *m = DatanodeInfoProto{} }
func (m *DatanodeInfoProto) String() string            { return proto.CompactTextString(m) }
func (*DatanodeInfoProto) ProtoMessage()               {}
func (*DatanodeInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{4} }

const Default_DatanodeInfoProto_Capacity uint64 = 0
const Default_DatanodeInfoProto_DfsUsed uint64 = 0
const Default_DatanodeInfoProto_Remaining uint64 = 0
const Default_DatanodeInfoProto_BlockPoolUsed uint64 = 0
const Default_DatanodeInfoProto_LastUpdate uint64 = 0
const Default_DatanodeInfoProto_XceiverCount uint32 = 0
const Default_DatanodeInfoProto_AdminState DatanodeInfoProto_AdminState = DatanodeInfoProto_NORMAL
const Default_DatanodeInfoProto_CacheCapacity uint64 = 0
const Default_DatanodeInfoProto_CacheUsed uint64 = 0

func (m *DatanodeInfoProto) GetId() *DatanodeIDProto {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DatanodeInfoProto) GetCapacity() uint64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return Default_DatanodeInfoProto_Capacity
}

func (m *DatanodeInfoProto) GetDfsUsed() uint64 {
	if m != nil && m.DfsUsed != nil {
		return *m.DfsUsed
	}
	return Default_DatanodeInfoProto_DfsUsed
}

func (m *DatanodeInfoProto) GetRemaining() uint64 {
	if m != nil && m.Remaining != nil {
		return *m.Remaining
	}
	return Default_DatanodeInfoProto_Remaining
}

func (m *DatanodeInfoProto) GetBlockPoolUsed() uint64 {
	if m != nil && m.BlockPoolUsed != nil {
		return *m.BlockPoolUsed
	}
	return Default_DatanodeInfoProto_BlockPoolUsed
}

func (m *DatanodeInfoProto) GetLastUpdate() uint64 {
	if m != nil && m.LastUpdate != nil {
		return *m.LastUpdate
	}
	return Default_DatanodeInfoProto_LastUpdate
}

func (m *DatanodeInfoProto) GetXceiverCount() uint32 {
	if m != nil && m.XceiverCount != nil {
		return *m.XceiverCount
	}
	return Default_DatanodeInfoProto_XceiverCount
}

func (m *DatanodeInfoProto) GetLocation() string {
	if m != nil && m.Location != nil {
		return *m.Location
	}
	return ""
}

func (m *DatanodeInfoProto) GetAdminState() DatanodeInfoProto_AdminState {
	if m != nil && m.AdminState != nil {
		return *m.AdminState
	}
	return Default_DatanodeInfoProto_AdminState
}

func (m *DatanodeInfoProto) GetCacheCapacity() uint64 {
	if m != nil && m.CacheCapacity != nil {
		return *m.CacheCapacity
	}
	return Default_DatanodeInfoProto_CacheCapacity
}

func (m *DatanodeInfoProto) GetCacheUsed() uint64 {
	if m != nil && m.CacheUsed != nil {
		return *m.CacheUsed
	}
	return Default_DatanodeInfoProto_CacheUsed
}

// *
// Represents a storage available on the datanode
type DatanodeStorageProto struct {
	StorageUuid      *string                            `protobuf:"bytes,1,req,name=storageUuid" json:"storageUuid,omitempty"`
	State            *DatanodeStorageProto_StorageState `protobuf:"varint,2,opt,name=state,enum=hadoop.hdfs.DatanodeStorageProto_StorageState,def=0" json:"state,omitempty"`
	StorageType      *StorageTypeProto                  `protobuf:"varint,3,opt,name=storageType,enum=hadoop.hdfs.StorageTypeProto,def=1" json:"storageType,omitempty"`
	XXX_unrecognized []byte                             `json:"-"`
}

func (m *DatanodeStorageProto) Reset()                    { *m = DatanodeStorageProto{} }
func (m *DatanodeStorageProto) String() string            { return proto.CompactTextString(m) }
func (*DatanodeStorageProto) ProtoMessage()               {}
func (*DatanodeStorageProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{5} }

const Default_DatanodeStorageProto_State DatanodeStorageProto_StorageState = DatanodeStorageProto_NORMAL
const Default_DatanodeStorageProto_StorageType StorageTypeProto = StorageTypeProto_DISK

func (m *DatanodeStorageProto) GetStorageUuid() string {
	if m != nil && m.StorageUuid != nil {
		return *m.StorageUuid
	}
	return ""
}

func (m *DatanodeStorageProto) GetState() DatanodeStorageProto_StorageState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return Default_DatanodeStorageProto_State
}

func (m *DatanodeStorageProto) GetStorageType() StorageTypeProto {
	if m != nil && m.StorageType != nil {
		return *m.StorageType
	}
	return Default_DatanodeStorageProto_StorageType
}

type StorageReportProto struct {
	StorageUuid      *string               `protobuf:"bytes,1,req,name=storageUuid" json:"storageUuid,omitempty"`
	Failed           *bool                 `protobuf:"varint,2,opt,name=failed,def=0" json:"failed,omitempty"`
	Capacity         *uint64               `protobuf:"varint,3,opt,name=capacity,def=0" json:"capacity,omitempty"`
	DfsUsed          *uint64               `protobuf:"varint,4,opt,name=dfsUsed,def=0" json:"dfsUsed,omitempty"`
	Remaining        *uint64               `protobuf:"varint,5,opt,name=remaining,def=0" json:"remaining,omitempty"`
	BlockPoolUsed    *uint64               `protobuf:"varint,6,opt,name=blockPoolUsed,def=0" json:"blockPoolUsed,omitempty"`
	Storage          *DatanodeStorageProto `protobuf:"bytes,7,opt,name=storage" json:"storage,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *StorageReportProto) Reset()                    { *m = StorageReportProto{} }
func (m *StorageReportProto) String() string            { return proto.CompactTextString(m) }
func (*StorageReportProto) ProtoMessage()               {}
func (*StorageReportProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{6} }

const Default_StorageReportProto_Failed bool = false
const Default_StorageReportProto_Capacity uint64 = 0
const Default_StorageReportProto_DfsUsed uint64 = 0
const Default_StorageReportProto_Remaining uint64 = 0
const Default_StorageReportProto_BlockPoolUsed uint64 = 0

func (m *StorageReportProto) GetStorageUuid() string {
	if m != nil && m.StorageUuid != nil {
		return *m.StorageUuid
	}
	return ""
}

func (m *StorageReportProto) GetFailed() bool {
	if m != nil && m.Failed != nil {
		return *m.Failed
	}
	return Default_StorageReportProto_Failed
}

func (m *StorageReportProto) GetCapacity() uint64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return Default_StorageReportProto_Capacity
}

func (m *StorageReportProto) GetDfsUsed() uint64 {
	if m != nil && m.DfsUsed != nil {
		return *m.DfsUsed
	}
	return Default_StorageReportProto_DfsUsed
}

func (m *StorageReportProto) GetRemaining() uint64 {
	if m != nil && m.Remaining != nil {
		return *m.Remaining
	}
	return Default_StorageReportProto_Remaining
}

func (m *StorageReportProto) GetBlockPoolUsed() uint64 {
	if m != nil && m.BlockPoolUsed != nil {
		return *m.BlockPoolUsed
	}
	return Default_StorageReportProto_BlockPoolUsed
}

func (m *StorageReportProto) GetStorage() *DatanodeStorageProto {
	if m != nil {
		return m.Storage
	}
	return nil
}

// *
// Summary of a file or directory
type ContentSummaryProto struct {
	Length           *uint64 `protobuf:"varint,1,req,name=length" json:"length,omitempty"`
	FileCount        *uint64 `protobuf:"varint,2,req,name=fileCount" json:"fileCount,omitempty"`
	DirectoryCount   *uint64 `protobuf:"varint,3,req,name=directoryCount" json:"directoryCount,omitempty"`
	Quota            *uint64 `protobuf:"varint,4,req,name=quota" json:"quota,omitempty"`
	SpaceConsumed    *uint64 `protobuf:"varint,5,req,name=spaceConsumed" json:"spaceConsumed,omitempty"`
	SpaceQuota       *uint64 `protobuf:"varint,6,req,name=spaceQuota" json:"spaceQuota,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ContentSummaryProto) Reset()                    { *m = ContentSummaryProto{} }
func (m *ContentSummaryProto) String() string            { return proto.CompactTextString(m) }
func (*ContentSummaryProto) ProtoMessage()               {}
func (*ContentSummaryProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{7} }

func (m *ContentSummaryProto) GetLength() uint64 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *ContentSummaryProto) GetFileCount() uint64 {
	if m != nil && m.FileCount != nil {
		return *m.FileCount
	}
	return 0
}

func (m *ContentSummaryProto) GetDirectoryCount() uint64 {
	if m != nil && m.DirectoryCount != nil {
		return *m.DirectoryCount
	}
	return 0
}

func (m *ContentSummaryProto) GetQuota() uint64 {
	if m != nil && m.Quota != nil {
		return *m.Quota
	}
	return 0
}

func (m *ContentSummaryProto) GetSpaceConsumed() uint64 {
	if m != nil && m.SpaceConsumed != nil {
		return *m.SpaceConsumed
	}
	return 0
}

func (m *ContentSummaryProto) GetSpaceQuota() uint64 {
	if m != nil && m.SpaceQuota != nil {
		return *m.SpaceQuota
	}
	return 0
}

// *
// Contains a list of paths corresponding to corrupt files and a cookie
// used for iterative calls to NameNode.listCorruptFileBlocks.
//
type CorruptFileBlocksProto struct {
	Files            []string `protobuf:"bytes,1,rep,name=files" json:"files,omitempty"`
	Cookie           *string  `protobuf:"bytes,2,req,name=cookie" json:"cookie,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CorruptFileBlocksProto) Reset()                    { *m = CorruptFileBlocksProto{} }
func (m *CorruptFileBlocksProto) String() string            { return proto.CompactTextString(m) }
func (*CorruptFileBlocksProto) ProtoMessage()               {}
func (*CorruptFileBlocksProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{8} }

func (m *CorruptFileBlocksProto) GetFiles() []string {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *CorruptFileBlocksProto) GetCookie() string {
	if m != nil && m.Cookie != nil {
		return *m.Cookie
	}
	return ""
}

// *
// File or Directory permision - same spec as posix
type FsPermissionProto struct {
	Perm             *uint32 `protobuf:"varint,1,req,name=perm" json:"perm,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FsPermissionProto) Reset()                    { *m = FsPermissionProto{} }
func (m *FsPermissionProto) String() string            { return proto.CompactTextString(m) }
func (*FsPermissionProto) ProtoMessage()               {}
func (*FsPermissionProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{9} }

func (m *FsPermissionProto) GetPerm() uint32 {
	if m != nil && m.Perm != nil {
		return *m.Perm
	}
	return 0
}

// *
// A list of storage types.
type StorageTypesProto struct {
	StorageTypes     []StorageTypeProto `protobuf:"varint,1,rep,name=storageTypes,enum=hadoop.hdfs.StorageTypeProto" json:"storageTypes,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *StorageTypesProto) Reset()                    { *m = StorageTypesProto{} }
func (m *StorageTypesProto) String() string            { return proto.CompactTextString(m) }
func (*StorageTypesProto) ProtoMessage()               {}
func (*StorageTypesProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{10} }

func (m *StorageTypesProto) GetStorageTypes() []StorageTypeProto {
	if m != nil {
		return m.StorageTypes
	}
	return nil
}

// *
// A list of storage IDs.
type StorageUuidsProto struct {
	StorageUuids     []string `protobuf:"bytes,1,rep,name=storageUuids" json:"storageUuids,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *StorageUuidsProto) Reset()                    { *m = StorageUuidsProto{} }
func (m *StorageUuidsProto) String() string            { return proto.CompactTextString(m) }
func (*StorageUuidsProto) ProtoMessage()               {}
func (*StorageUuidsProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{11} }

func (m *StorageUuidsProto) GetStorageUuids() []string {
	if m != nil {
		return m.StorageUuids
	}
	return nil
}

// *
// A LocatedBlock gives information about a block and its location.
type LocatedBlockProto struct {
	B                *ExtendedBlockProto       `protobuf:"bytes,1,req,name=b" json:"b,omitempty"`
	Offset           *uint64                   `protobuf:"varint,2,req,name=offset" json:"offset,omitempty"`
	Locs             []*DatanodeInfoProto      `protobuf:"bytes,3,rep,name=locs" json:"locs,omitempty"`
	Corrupt          *bool                     `protobuf:"varint,4,req,name=corrupt" json:"corrupt,omitempty"`
	BlockToken       *hadoop_common.TokenProto `protobuf:"bytes,5,req,name=blockToken" json:"blockToken,omitempty"`
	IsCached         []bool                    `protobuf:"varint,6,rep,packed,name=isCached" json:"isCached,omitempty"`
	StorageTypes     []StorageTypeProto        `protobuf:"varint,7,rep,name=storageTypes,enum=hadoop.hdfs.StorageTypeProto" json:"storageTypes,omitempty"`
	StorageIDs       []string                  `protobuf:"bytes,8,rep,name=storageIDs" json:"storageIDs,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *LocatedBlockProto) Reset()                    { *m = LocatedBlockProto{} }
func (m *LocatedBlockProto) String() string            { return proto.CompactTextString(m) }
func (*LocatedBlockProto) ProtoMessage()               {}
func (*LocatedBlockProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{12} }

func (m *LocatedBlockProto) GetB() *ExtendedBlockProto {
	if m != nil {
		return m.B
	}
	return nil
}

func (m *LocatedBlockProto) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *LocatedBlockProto) GetLocs() []*DatanodeInfoProto {
	if m != nil {
		return m.Locs
	}
	return nil
}

func (m *LocatedBlockProto) GetCorrupt() bool {
	if m != nil && m.Corrupt != nil {
		return *m.Corrupt
	}
	return false
}

func (m *LocatedBlockProto) GetBlockToken() *hadoop_common.TokenProto {
	if m != nil {
		return m.BlockToken
	}
	return nil
}

func (m *LocatedBlockProto) GetIsCached() []bool {
	if m != nil {
		return m.IsCached
	}
	return nil
}

func (m *LocatedBlockProto) GetStorageTypes() []StorageTypeProto {
	if m != nil {
		return m.StorageTypes
	}
	return nil
}

func (m *LocatedBlockProto) GetStorageIDs() []string {
	if m != nil {
		return m.StorageIDs
	}
	return nil
}

type DataEncryptionKeyProto struct {
	KeyId               *uint32 `protobuf:"varint,1,req,name=keyId" json:"keyId,omitempty"`
	BlockPoolId         *string `protobuf:"bytes,2,req,name=blockPoolId" json:"blockPoolId,omitempty"`
	Nonce               []byte  `protobuf:"bytes,3,req,name=nonce" json:"nonce,omitempty"`
	EncryptionKey       []byte  `protobuf:"bytes,4,req,name=encryptionKey" json:"encryptionKey,omitempty"`
	ExpiryDate          *uint64 `protobuf:"varint,5,req,name=expiryDate" json:"expiryDate,omitempty"`
	EncryptionAlgorithm *string `protobuf:"bytes,6,opt,name=encryptionAlgorithm" json:"encryptionAlgorithm,omitempty"`
	XXX_unrecognized    []byte  `json:"-"`
}

func (m *DataEncryptionKeyProto) Reset()                    { *m = DataEncryptionKeyProto{} }
func (m *DataEncryptionKeyProto) String() string            { return proto.CompactTextString(m) }
func (*DataEncryptionKeyProto) ProtoMessage()               {}
func (*DataEncryptionKeyProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{13} }

func (m *DataEncryptionKeyProto) GetKeyId() uint32 {
	if m != nil && m.KeyId != nil {
		return *m.KeyId
	}
	return 0
}

func (m *DataEncryptionKeyProto) GetBlockPoolId() string {
	if m != nil && m.BlockPoolId != nil {
		return *m.BlockPoolId
	}
	return ""
}

func (m *DataEncryptionKeyProto) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *DataEncryptionKeyProto) GetEncryptionKey() []byte {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

func (m *DataEncryptionKeyProto) GetExpiryDate() uint64 {
	if m != nil && m.ExpiryDate != nil {
		return *m.ExpiryDate
	}
	return 0
}

func (m *DataEncryptionKeyProto) GetEncryptionAlgorithm() string {
	if m != nil && m.EncryptionAlgorithm != nil {
		return *m.EncryptionAlgorithm
	}
	return ""
}

// *
// Encryption information for a file.
type FileEncryptionInfoProto struct {
	Suite                 *CipherSuiteProto           `protobuf:"varint,1,req,name=suite,enum=hadoop.hdfs.CipherSuiteProto" json:"suite,omitempty"`
	CryptoProtocolVersion *CryptoProtocolVersionProto `protobuf:"varint,2,req,name=cryptoProtocolVersion,enum=hadoop.hdfs.CryptoProtocolVersionProto" json:"cryptoProtocolVersion,omitempty"`
	Key                   []byte                      `protobuf:"bytes,3,req,name=key" json:"key,omitempty"`
	Iv                    []byte                      `protobuf:"bytes,4,req,name=iv" json:"iv,omitempty"`
	KeyName               *string                     `protobuf:"bytes,5,req,name=keyName" json:"keyName,omitempty"`
	EzKeyVersionName      *string                     `protobuf:"bytes,6,req,name=ezKeyVersionName" json:"ezKeyVersionName,omitempty"`
	XXX_unrecognized      []byte                      `json:"-"`
}

func (m *FileEncryptionInfoProto) Reset()                    { *m = FileEncryptionInfoProto{} }
func (m *FileEncryptionInfoProto) String() string            { return proto.CompactTextString(m) }
func (*FileEncryptionInfoProto) ProtoMessage()               {}
func (*FileEncryptionInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{14} }

func (m *FileEncryptionInfoProto) GetSuite() CipherSuiteProto {
	if m != nil && m.Suite != nil {
		return *m.Suite
	}
	return CipherSuiteProto_UNKNOWN
}

func (m *FileEncryptionInfoProto) GetCryptoProtocolVersion() CryptoProtocolVersionProto {
	if m != nil && m.CryptoProtocolVersion != nil {
		return *m.CryptoProtocolVersion
	}
	return CryptoProtocolVersionProto_UNKNOWN_PROTOCOL_VERSION
}

func (m *FileEncryptionInfoProto) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *FileEncryptionInfoProto) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *FileEncryptionInfoProto) GetKeyName() string {
	if m != nil && m.KeyName != nil {
		return *m.KeyName
	}
	return ""
}

func (m *FileEncryptionInfoProto) GetEzKeyVersionName() string {
	if m != nil && m.EzKeyVersionName != nil {
		return *m.EzKeyVersionName
	}
	return ""
}

// *
// Encryption information for an individual
// file within an encryption zone
type PerFileEncryptionInfoProto struct {
	Key              []byte  `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Iv               []byte  `protobuf:"bytes,2,req,name=iv" json:"iv,omitempty"`
	EzKeyVersionName *string `protobuf:"bytes,3,req,name=ezKeyVersionName" json:"ezKeyVersionName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PerFileEncryptionInfoProto) Reset()                    { *m = PerFileEncryptionInfoProto{} }
func (m *PerFileEncryptionInfoProto) String() string            { return proto.CompactTextString(m) }
func (*PerFileEncryptionInfoProto) ProtoMessage()               {}
func (*PerFileEncryptionInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{15} }

func (m *PerFileEncryptionInfoProto) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *PerFileEncryptionInfoProto) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *PerFileEncryptionInfoProto) GetEzKeyVersionName() string {
	if m != nil && m.EzKeyVersionName != nil {
		return *m.EzKeyVersionName
	}
	return ""
}

// *
// Encryption information for an encryption
// zone
type ZoneEncryptionInfoProto struct {
	Suite                 *CipherSuiteProto           `protobuf:"varint,1,req,name=suite,enum=hadoop.hdfs.CipherSuiteProto" json:"suite,omitempty"`
	CryptoProtocolVersion *CryptoProtocolVersionProto `protobuf:"varint,2,req,name=cryptoProtocolVersion,enum=hadoop.hdfs.CryptoProtocolVersionProto" json:"cryptoProtocolVersion,omitempty"`
	KeyName               *string                     `protobuf:"bytes,3,req,name=keyName" json:"keyName,omitempty"`
	XXX_unrecognized      []byte                      `json:"-"`
}

func (m *ZoneEncryptionInfoProto) Reset()                    { *m = ZoneEncryptionInfoProto{} }
func (m *ZoneEncryptionInfoProto) String() string            { return proto.CompactTextString(m) }
func (*ZoneEncryptionInfoProto) ProtoMessage()               {}
func (*ZoneEncryptionInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{16} }

func (m *ZoneEncryptionInfoProto) GetSuite() CipherSuiteProto {
	if m != nil && m.Suite != nil {
		return *m.Suite
	}
	return CipherSuiteProto_UNKNOWN
}

func (m *ZoneEncryptionInfoProto) GetCryptoProtocolVersion() CryptoProtocolVersionProto {
	if m != nil && m.CryptoProtocolVersion != nil {
		return *m.CryptoProtocolVersion
	}
	return CryptoProtocolVersionProto_UNKNOWN_PROTOCOL_VERSION
}

func (m *ZoneEncryptionInfoProto) GetKeyName() string {
	if m != nil && m.KeyName != nil {
		return *m.KeyName
	}
	return ""
}

// *
// A set of file blocks and their locations.
type LocatedBlocksProto struct {
	FileLength          *uint64                  `protobuf:"varint,1,req,name=fileLength" json:"fileLength,omitempty"`
	Blocks              []*LocatedBlockProto     `protobuf:"bytes,2,rep,name=blocks" json:"blocks,omitempty"`
	UnderConstruction   *bool                    `protobuf:"varint,3,req,name=underConstruction" json:"underConstruction,omitempty"`
	LastBlock           *LocatedBlockProto       `protobuf:"bytes,4,opt,name=lastBlock" json:"lastBlock,omitempty"`
	IsLastBlockComplete *bool                    `protobuf:"varint,5,req,name=isLastBlockComplete" json:"isLastBlockComplete,omitempty"`
	FileEncryptionInfo  *FileEncryptionInfoProto `protobuf:"bytes,6,opt,name=fileEncryptionInfo" json:"fileEncryptionInfo,omitempty"`
	XXX_unrecognized    []byte                   `json:"-"`
}

func (m *LocatedBlocksProto) Reset()                    { *m = LocatedBlocksProto{} }
func (m *LocatedBlocksProto) String() string            { return proto.CompactTextString(m) }
func (*LocatedBlocksProto) ProtoMessage()               {}
func (*LocatedBlocksProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{17} }

func (m *LocatedBlocksProto) GetFileLength() uint64 {
	if m != nil && m.FileLength != nil {
		return *m.FileLength
	}
	return 0
}

func (m *LocatedBlocksProto) GetBlocks() []*LocatedBlockProto {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *LocatedBlocksProto) GetUnderConstruction() bool {
	if m != nil && m.UnderConstruction != nil {
		return *m.UnderConstruction
	}
	return false
}

func (m *LocatedBlocksProto) GetLastBlock() *LocatedBlockProto {
	if m != nil {
		return m.LastBlock
	}
	return nil
}

func (m *LocatedBlocksProto) GetIsLastBlockComplete() bool {
	if m != nil && m.IsLastBlockComplete != nil {
		return *m.IsLastBlockComplete
	}
	return false
}

func (m *LocatedBlocksProto) GetFileEncryptionInfo() *FileEncryptionInfoProto {
	if m != nil {
		return m.FileEncryptionInfo
	}
	return nil
}

// *
// Status of a file, directory or symlink
// Optionally includes a file's block locations if requested by client on the rpc call.
type HdfsFileStatusProto struct {
	FileType         *HdfsFileStatusProto_FileType `protobuf:"varint,1,req,name=fileType,enum=hadoop.hdfs.HdfsFileStatusProto_FileType" json:"fileType,omitempty"`
	Path             []byte                        `protobuf:"bytes,2,req,name=path" json:"path,omitempty"`
	Length           *uint64                       `protobuf:"varint,3,req,name=length" json:"length,omitempty"`
	Permission       *FsPermissionProto            `protobuf:"bytes,4,req,name=permission" json:"permission,omitempty"`
	Owner            *string                       `protobuf:"bytes,5,req,name=owner" json:"owner,omitempty"`
	Group            *string                       `protobuf:"bytes,6,req,name=group" json:"group,omitempty"`
	ModificationTime *uint64                       `protobuf:"varint,7,req,name=modification_time,json=modificationTime" json:"modification_time,omitempty"`
	AccessTime       *uint64                       `protobuf:"varint,8,req,name=access_time,json=accessTime" json:"access_time,omitempty"`
	// Optional fields for symlink
	Symlink []byte `protobuf:"bytes,9,opt,name=symlink" json:"symlink,omitempty"`
	// Optional fields for file
	BlockReplication *uint32             `protobuf:"varint,10,opt,name=block_replication,json=blockReplication,def=0" json:"block_replication,omitempty"`
	Blocksize        *uint64             `protobuf:"varint,11,opt,name=blocksize,def=0" json:"blocksize,omitempty"`
	Locations        *LocatedBlocksProto `protobuf:"bytes,12,opt,name=locations" json:"locations,omitempty"`
	// Optional field for fileId
	FileId      *uint64 `protobuf:"varint,13,opt,name=fileId,def=0" json:"fileId,omitempty"`
	ChildrenNum *int32  `protobuf:"varint,14,opt,name=childrenNum,def=-1" json:"childrenNum,omitempty"`
	// Optional field for file encryption
	FileEncryptionInfo *FileEncryptionInfoProto `protobuf:"bytes,15,opt,name=fileEncryptionInfo" json:"fileEncryptionInfo,omitempty"`
	XXX_unrecognized   []byte                   `json:"-"`
}

func (m *HdfsFileStatusProto) Reset()                    { *m = HdfsFileStatusProto{} }
func (m *HdfsFileStatusProto) String() string            { return proto.CompactTextString(m) }
func (*HdfsFileStatusProto) ProtoMessage()               {}
func (*HdfsFileStatusProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{18} }

const Default_HdfsFileStatusProto_BlockReplication uint32 = 0
const Default_HdfsFileStatusProto_Blocksize uint64 = 0
const Default_HdfsFileStatusProto_FileId uint64 = 0
const Default_HdfsFileStatusProto_ChildrenNum int32 = -1

func (m *HdfsFileStatusProto) GetFileType() HdfsFileStatusProto_FileType {
	if m != nil && m.FileType != nil {
		return *m.FileType
	}
	return HdfsFileStatusProto_IS_DIR
}

func (m *HdfsFileStatusProto) GetPath() []byte {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *HdfsFileStatusProto) GetLength() uint64 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *HdfsFileStatusProto) GetPermission() *FsPermissionProto {
	if m != nil {
		return m.Permission
	}
	return nil
}

func (m *HdfsFileStatusProto) GetOwner() string {
	if m != nil && m.Owner != nil {
		return *m.Owner
	}
	return ""
}

func (m *HdfsFileStatusProto) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *HdfsFileStatusProto) GetModificationTime() uint64 {
	if m != nil && m.ModificationTime != nil {
		return *m.ModificationTime
	}
	return 0
}

func (m *HdfsFileStatusProto) GetAccessTime() uint64 {
	if m != nil && m.AccessTime != nil {
		return *m.AccessTime
	}
	return 0
}

func (m *HdfsFileStatusProto) GetSymlink() []byte {
	if m != nil {
		return m.Symlink
	}
	return nil
}

func (m *HdfsFileStatusProto) GetBlockReplication() uint32 {
	if m != nil && m.BlockReplication != nil {
		return *m.BlockReplication
	}
	return Default_HdfsFileStatusProto_BlockReplication
}

func (m *HdfsFileStatusProto) GetBlocksize() uint64 {
	if m != nil && m.Blocksize != nil {
		return *m.Blocksize
	}
	return Default_HdfsFileStatusProto_Blocksize
}

func (m *HdfsFileStatusProto) GetLocations() *LocatedBlocksProto {
	if m != nil {
		return m.Locations
	}
	return nil
}

func (m *HdfsFileStatusProto) GetFileId() uint64 {
	if m != nil && m.FileId != nil {
		return *m.FileId
	}
	return Default_HdfsFileStatusProto_FileId
}

func (m *HdfsFileStatusProto) GetChildrenNum() int32 {
	if m != nil && m.ChildrenNum != nil {
		return *m.ChildrenNum
	}
	return Default_HdfsFileStatusProto_ChildrenNum
}

func (m *HdfsFileStatusProto) GetFileEncryptionInfo() *FileEncryptionInfoProto {
	if m != nil {
		return m.FileEncryptionInfo
	}
	return nil
}

// *
// HDFS Server Defaults
type FsServerDefaultsProto struct {
	BlockSize           *uint64            `protobuf:"varint,1,req,name=blockSize" json:"blockSize,omitempty"`
	BytesPerChecksum    *uint32            `protobuf:"varint,2,req,name=bytesPerChecksum" json:"bytesPerChecksum,omitempty"`
	WritePacketSize     *uint32            `protobuf:"varint,3,req,name=writePacketSize" json:"writePacketSize,omitempty"`
	Replication         *uint32            `protobuf:"varint,4,req,name=replication" json:"replication,omitempty"`
	FileBufferSize      *uint32            `protobuf:"varint,5,req,name=fileBufferSize" json:"fileBufferSize,omitempty"`
	EncryptDataTransfer *bool              `protobuf:"varint,6,opt,name=encryptDataTransfer,def=0" json:"encryptDataTransfer,omitempty"`
	TrashInterval       *uint64            `protobuf:"varint,7,opt,name=trashInterval,def=0" json:"trashInterval,omitempty"`
	ChecksumType        *ChecksumTypeProto `protobuf:"varint,8,opt,name=checksumType,enum=hadoop.hdfs.ChecksumTypeProto,def=1" json:"checksumType,omitempty"`
	XXX_unrecognized    []byte             `json:"-"`
}

func (m *FsServerDefaultsProto) Reset()                    { *m = FsServerDefaultsProto{} }
func (m *FsServerDefaultsProto) String() string            { return proto.CompactTextString(m) }
func (*FsServerDefaultsProto) ProtoMessage()               {}
func (*FsServerDefaultsProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{19} }

const Default_FsServerDefaultsProto_EncryptDataTransfer bool = false
const Default_FsServerDefaultsProto_TrashInterval uint64 = 0
const Default_FsServerDefaultsProto_ChecksumType ChecksumTypeProto = ChecksumTypeProto_CHECKSUM_CRC32

func (m *FsServerDefaultsProto) GetBlockSize() uint64 {
	if m != nil && m.BlockSize != nil {
		return *m.BlockSize
	}
	return 0
}

func (m *FsServerDefaultsProto) GetBytesPerChecksum() uint32 {
	if m != nil && m.BytesPerChecksum != nil {
		return *m.BytesPerChecksum
	}
	return 0
}

func (m *FsServerDefaultsProto) GetWritePacketSize() uint32 {
	if m != nil && m.WritePacketSize != nil {
		return *m.WritePacketSize
	}
	return 0
}

func (m *FsServerDefaultsProto) GetReplication() uint32 {
	if m != nil && m.Replication != nil {
		return *m.Replication
	}
	return 0
}

func (m *FsServerDefaultsProto) GetFileBufferSize() uint32 {
	if m != nil && m.FileBufferSize != nil {
		return *m.FileBufferSize
	}
	return 0
}

func (m *FsServerDefaultsProto) GetEncryptDataTransfer() bool {
	if m != nil && m.EncryptDataTransfer != nil {
		return *m.EncryptDataTransfer
	}
	return Default_FsServerDefaultsProto_EncryptDataTransfer
}

func (m *FsServerDefaultsProto) GetTrashInterval() uint64 {
	if m != nil && m.TrashInterval != nil {
		return *m.TrashInterval
	}
	return Default_FsServerDefaultsProto_TrashInterval
}

func (m *FsServerDefaultsProto) GetChecksumType() ChecksumTypeProto {
	if m != nil && m.ChecksumType != nil {
		return *m.ChecksumType
	}
	return Default_FsServerDefaultsProto_ChecksumType
}

// *
// Directory listing
type DirectoryListingProto struct {
	PartialListing   []*HdfsFileStatusProto `protobuf:"bytes,1,rep,name=partialListing" json:"partialListing,omitempty"`
	RemainingEntries *uint32                `protobuf:"varint,2,req,name=remainingEntries" json:"remainingEntries,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *DirectoryListingProto) Reset()                    { *m = DirectoryListingProto{} }
func (m *DirectoryListingProto) String() string            { return proto.CompactTextString(m) }
func (*DirectoryListingProto) ProtoMessage()               {}
func (*DirectoryListingProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{20} }

func (m *DirectoryListingProto) GetPartialListing() []*HdfsFileStatusProto {
	if m != nil {
		return m.PartialListing
	}
	return nil
}

func (m *DirectoryListingProto) GetRemainingEntries() uint32 {
	if m != nil && m.RemainingEntries != nil {
		return *m.RemainingEntries
	}
	return 0
}

// *
// Status of a snapshottable directory: besides the normal information for
// a directory status, also include snapshot quota, number of snapshots, and
// the full path of the parent directory.
type SnapshottableDirectoryStatusProto struct {
	DirStatus *HdfsFileStatusProto `protobuf:"bytes,1,req,name=dirStatus" json:"dirStatus,omitempty"`
	// Fields specific for snapshottable directory
	SnapshotQuota    *uint32 `protobuf:"varint,2,req,name=snapshot_quota,json=snapshotQuota" json:"snapshot_quota,omitempty"`
	SnapshotNumber   *uint32 `protobuf:"varint,3,req,name=snapshot_number,json=snapshotNumber" json:"snapshot_number,omitempty"`
	ParentFullpath   []byte  `protobuf:"bytes,4,req,name=parent_fullpath,json=parentFullpath" json:"parent_fullpath,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SnapshottableDirectoryStatusProto) Reset()         { *m = SnapshottableDirectoryStatusProto{} }
func (m *SnapshottableDirectoryStatusProto) String() string { return proto.CompactTextString(m) }
func (*SnapshottableDirectoryStatusProto) ProtoMessage()    {}
func (*SnapshottableDirectoryStatusProto) Descriptor() ([]byte, []int) {
	return fileDescriptorHdfs, []int{21}
}

func (m *SnapshottableDirectoryStatusProto) GetDirStatus() *HdfsFileStatusProto {
	if m != nil {
		return m.DirStatus
	}
	return nil
}

func (m *SnapshottableDirectoryStatusProto) GetSnapshotQuota() uint32 {
	if m != nil && m.SnapshotQuota != nil {
		return *m.SnapshotQuota
	}
	return 0
}

func (m *SnapshottableDirectoryStatusProto) GetSnapshotNumber() uint32 {
	if m != nil && m.SnapshotNumber != nil {
		return *m.SnapshotNumber
	}
	return 0
}

func (m *SnapshottableDirectoryStatusProto) GetParentFullpath() []byte {
	if m != nil {
		return m.ParentFullpath
	}
	return nil
}

// *
// Snapshottable directory listing
type SnapshottableDirectoryListingProto struct {
	SnapshottableDirListing []*SnapshottableDirectoryStatusProto `protobuf:"bytes,1,rep,name=snapshottableDirListing" json:"snapshottableDirListing,omitempty"`
	XXX_unrecognized        []byte                               `json:"-"`
}

func (m *SnapshottableDirectoryListingProto) Reset()         { *m = SnapshottableDirectoryListingProto{} }
func (m *SnapshottableDirectoryListingProto) String() string { return proto.CompactTextString(m) }
func (*SnapshottableDirectoryListingProto) ProtoMessage()    {}
func (*SnapshottableDirectoryListingProto) Descriptor() ([]byte, []int) {
	return fileDescriptorHdfs, []int{22}
}

func (m *SnapshottableDirectoryListingProto) GetSnapshottableDirListing() []*SnapshottableDirectoryStatusProto {
	if m != nil {
		return m.SnapshottableDirListing
	}
	return nil
}

// *
// Snapshot diff report entry
type SnapshotDiffReportEntryProto struct {
	Fullpath          []byte  `protobuf:"bytes,1,req,name=fullpath" json:"fullpath,omitempty"`
	ModificationLabel *string `protobuf:"bytes,2,req,name=modificationLabel" json:"modificationLabel,omitempty"`
	TargetPath        []byte  `protobuf:"bytes,3,opt,name=targetPath" json:"targetPath,omitempty"`
	XXX_unrecognized  []byte  `json:"-"`
}

func (m *SnapshotDiffReportEntryProto) Reset()         { *m = SnapshotDiffReportEntryProto{} }
func (m *SnapshotDiffReportEntryProto) String() string { return proto.CompactTextString(m) }
func (*SnapshotDiffReportEntryProto) ProtoMessage()    {}
func (*SnapshotDiffReportEntryProto) Descriptor() ([]byte, []int) {
	return fileDescriptorHdfs, []int{23}
}

func (m *SnapshotDiffReportEntryProto) GetFullpath() []byte {
	if m != nil {
		return m.Fullpath
	}
	return nil
}

func (m *SnapshotDiffReportEntryProto) GetModificationLabel() string {
	if m != nil && m.ModificationLabel != nil {
		return *m.ModificationLabel
	}
	return ""
}

func (m *SnapshotDiffReportEntryProto) GetTargetPath() []byte {
	if m != nil {
		return m.TargetPath
	}
	return nil
}

// *
// Snapshot diff report
type SnapshotDiffReportProto struct {
	// full path of the directory where snapshots were taken
	SnapshotRoot      *string                         `protobuf:"bytes,1,req,name=snapshotRoot" json:"snapshotRoot,omitempty"`
	FromSnapshot      *string                         `protobuf:"bytes,2,req,name=fromSnapshot" json:"fromSnapshot,omitempty"`
	ToSnapshot        *string                         `protobuf:"bytes,3,req,name=toSnapshot" json:"toSnapshot,omitempty"`
	DiffReportEntries []*SnapshotDiffReportEntryProto `protobuf:"bytes,4,rep,name=diffReportEntries" json:"diffReportEntries,omitempty"`
	XXX_unrecognized  []byte                          `json:"-"`
}

func (m *SnapshotDiffReportProto) Reset()                    { *m = SnapshotDiffReportProto{} }
func (m *SnapshotDiffReportProto) String() string            { return proto.CompactTextString(m) }
func (*SnapshotDiffReportProto) ProtoMessage()               {}
func (*SnapshotDiffReportProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{24} }

func (m *SnapshotDiffReportProto) GetSnapshotRoot() string {
	if m != nil && m.SnapshotRoot != nil {
		return *m.SnapshotRoot
	}
	return ""
}

func (m *SnapshotDiffReportProto) GetFromSnapshot() string {
	if m != nil && m.FromSnapshot != nil {
		return *m.FromSnapshot
	}
	return ""
}

func (m *SnapshotDiffReportProto) GetToSnapshot() string {
	if m != nil && m.ToSnapshot != nil {
		return *m.ToSnapshot
	}
	return ""
}

func (m *SnapshotDiffReportProto) GetDiffReportEntries() []*SnapshotDiffReportEntryProto {
	if m != nil {
		return m.DiffReportEntries
	}
	return nil
}

// *
// Common node information shared by all the nodes in the cluster
type StorageInfoProto struct {
	LayoutVersion    *uint32 `protobuf:"varint,1,req,name=layoutVersion" json:"layoutVersion,omitempty"`
	NamespceID       *uint32 `protobuf:"varint,2,req,name=namespceID" json:"namespceID,omitempty"`
	ClusterID        *string `protobuf:"bytes,3,req,name=clusterID" json:"clusterID,omitempty"`
	CTime            *uint64 `protobuf:"varint,4,req,name=cTime" json:"cTime,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StorageInfoProto) Reset()                    { *m = StorageInfoProto{} }
func (m *StorageInfoProto) String() string            { return proto.CompactTextString(m) }
func (*StorageInfoProto) ProtoMessage()               {}
func (*StorageInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{25} }

func (m *StorageInfoProto) GetLayoutVersion() uint32 {
	if m != nil && m.LayoutVersion != nil {
		return *m.LayoutVersion
	}
	return 0
}

func (m *StorageInfoProto) GetNamespceID() uint32 {
	if m != nil && m.NamespceID != nil {
		return *m.NamespceID
	}
	return 0
}

func (m *StorageInfoProto) GetClusterID() string {
	if m != nil && m.ClusterID != nil {
		return *m.ClusterID
	}
	return ""
}

func (m *StorageInfoProto) GetCTime() uint64 {
	if m != nil && m.CTime != nil {
		return *m.CTime
	}
	return 0
}

// *
// Information sent by a namenode to identify itself to the primary namenode.
type NamenodeRegistrationProto struct {
	RpcAddress       *string                                      `protobuf:"bytes,1,req,name=rpcAddress" json:"rpcAddress,omitempty"`
	HttpAddress      *string                                      `protobuf:"bytes,2,req,name=httpAddress" json:"httpAddress,omitempty"`
	StorageInfo      *StorageInfoProto                            `protobuf:"bytes,3,req,name=storageInfo" json:"storageInfo,omitempty"`
	Role             *NamenodeRegistrationProto_NamenodeRoleProto `protobuf:"varint,4,opt,name=role,enum=hadoop.hdfs.NamenodeRegistrationProto_NamenodeRoleProto,def=1" json:"role,omitempty"`
	XXX_unrecognized []byte                                       `json:"-"`
}

func (m *NamenodeRegistrationProto) Reset()                    { *m = NamenodeRegistrationProto{} }
func (m *NamenodeRegistrationProto) String() string            { return proto.CompactTextString(m) }
func (*NamenodeRegistrationProto) ProtoMessage()               {}
func (*NamenodeRegistrationProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{26} }

const Default_NamenodeRegistrationProto_Role NamenodeRegistrationProto_NamenodeRoleProto = NamenodeRegistrationProto_NAMENODE

func (m *NamenodeRegistrationProto) GetRpcAddress() string {
	if m != nil && m.RpcAddress != nil {
		return *m.RpcAddress
	}
	return ""
}

func (m *NamenodeRegistrationProto) GetHttpAddress() string {
	if m != nil && m.HttpAddress != nil {
		return *m.HttpAddress
	}
	return ""
}

func (m *NamenodeRegistrationProto) GetStorageInfo() *StorageInfoProto {
	if m != nil {
		return m.StorageInfo
	}
	return nil
}

func (m *NamenodeRegistrationProto) GetRole() NamenodeRegistrationProto_NamenodeRoleProto {
	if m != nil && m.Role != nil {
		return *m.Role
	}
	return Default_NamenodeRegistrationProto_Role
}

// *
// Unique signature to identify checkpoint transactions.
type CheckpointSignatureProto struct {
	BlockPoolId              *string           `protobuf:"bytes,1,req,name=blockPoolId" json:"blockPoolId,omitempty"`
	MostRecentCheckpointTxId *uint64           `protobuf:"varint,2,req,name=mostRecentCheckpointTxId" json:"mostRecentCheckpointTxId,omitempty"`
	CurSegmentTxId           *uint64           `protobuf:"varint,3,req,name=curSegmentTxId" json:"curSegmentTxId,omitempty"`
	StorageInfo              *StorageInfoProto `protobuf:"bytes,4,req,name=storageInfo" json:"storageInfo,omitempty"`
	XXX_unrecognized         []byte            `json:"-"`
}

func (m *CheckpointSignatureProto) Reset()                    { *m = CheckpointSignatureProto{} }
func (m *CheckpointSignatureProto) String() string            { return proto.CompactTextString(m) }
func (*CheckpointSignatureProto) ProtoMessage()               {}
func (*CheckpointSignatureProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{27} }

func (m *CheckpointSignatureProto) GetBlockPoolId() string {
	if m != nil && m.BlockPoolId != nil {
		return *m.BlockPoolId
	}
	return ""
}

func (m *CheckpointSignatureProto) GetMostRecentCheckpointTxId() uint64 {
	if m != nil && m.MostRecentCheckpointTxId != nil {
		return *m.MostRecentCheckpointTxId
	}
	return 0
}

func (m *CheckpointSignatureProto) GetCurSegmentTxId() uint64 {
	if m != nil && m.CurSegmentTxId != nil {
		return *m.CurSegmentTxId
	}
	return 0
}

func (m *CheckpointSignatureProto) GetStorageInfo() *StorageInfoProto {
	if m != nil {
		return m.StorageInfo
	}
	return nil
}

// *
// Command sent from one namenode to another namenode.
type NamenodeCommandProto struct {
	Action           *uint32                    `protobuf:"varint,1,req,name=action" json:"action,omitempty"`
	Type             *NamenodeCommandProto_Type `protobuf:"varint,2,req,name=type,enum=hadoop.hdfs.NamenodeCommandProto_Type" json:"type,omitempty"`
	CheckpointCmd    *CheckpointCommandProto    `protobuf:"bytes,3,opt,name=checkpointCmd" json:"checkpointCmd,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *NamenodeCommandProto) Reset()                    { *m = NamenodeCommandProto{} }
func (m *NamenodeCommandProto) String() string            { return proto.CompactTextString(m) }
func (*NamenodeCommandProto) ProtoMessage()               {}
func (*NamenodeCommandProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{28} }

func (m *NamenodeCommandProto) GetAction() uint32 {
	if m != nil && m.Action != nil {
		return *m.Action
	}
	return 0
}

func (m *NamenodeCommandProto) GetType() NamenodeCommandProto_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return NamenodeCommandProto_NamenodeCommand
}

func (m *NamenodeCommandProto) GetCheckpointCmd() *CheckpointCommandProto {
	if m != nil {
		return m.CheckpointCmd
	}
	return nil
}

// *
// Command returned from primary to checkpointing namenode.
// This command has checkpoint signature that identifies
// checkpoint transaction and is needed for further
// communication related to checkpointing.
type CheckpointCommandProto struct {
	// Unique signature to identify checkpoint transation
	Signature *CheckpointSignatureProto `protobuf:"bytes,1,req,name=signature" json:"signature,omitempty"`
	// If true, return transfer image to primary upon the completion of checkpoint
	NeedToReturnImage *bool  `protobuf:"varint,2,req,name=needToReturnImage" json:"needToReturnImage,omitempty"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *CheckpointCommandProto) Reset()                    { *m = CheckpointCommandProto{} }
func (m *CheckpointCommandProto) String() string            { return proto.CompactTextString(m) }
func (*CheckpointCommandProto) ProtoMessage()               {}
func (*CheckpointCommandProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{29} }

func (m *CheckpointCommandProto) GetSignature() *CheckpointSignatureProto {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *CheckpointCommandProto) GetNeedToReturnImage() bool {
	if m != nil && m.NeedToReturnImage != nil {
		return *m.NeedToReturnImage
	}
	return false
}

// *
// Block information
//
// Please be wary of adding additional fields here, since INodeFiles
// need to fit in PB's default max message size of 64MB.
// We restrict the max # of blocks per file
// (dfs.namenode.fs-limits.max-blocks-per-file), but it's better
// to avoid changing this.
type BlockProto struct {
	BlockId          *uint64 `protobuf:"varint,1,req,name=blockId" json:"blockId,omitempty"`
	GenStamp         *uint64 `protobuf:"varint,2,req,name=genStamp" json:"genStamp,omitempty"`
	NumBytes         *uint64 `protobuf:"varint,3,opt,name=numBytes,def=0" json:"numBytes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BlockProto) Reset()                    { *m = BlockProto{} }
func (m *BlockProto) String() string            { return proto.CompactTextString(m) }
func (*BlockProto) ProtoMessage()               {}
func (*BlockProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{30} }

const Default_BlockProto_NumBytes uint64 = 0

func (m *BlockProto) GetBlockId() uint64 {
	if m != nil && m.BlockId != nil {
		return *m.BlockId
	}
	return 0
}

func (m *BlockProto) GetGenStamp() uint64 {
	if m != nil && m.GenStamp != nil {
		return *m.GenStamp
	}
	return 0
}

func (m *BlockProto) GetNumBytes() uint64 {
	if m != nil && m.NumBytes != nil {
		return *m.NumBytes
	}
	return Default_BlockProto_NumBytes
}

// *
// Block and datanodes where is it located
type BlockWithLocationsProto struct {
	Block            *BlockProto        `protobuf:"bytes,1,req,name=block" json:"block,omitempty"`
	DatanodeUuids    []string           `protobuf:"bytes,2,rep,name=datanodeUuids" json:"datanodeUuids,omitempty"`
	StorageUuids     []string           `protobuf:"bytes,3,rep,name=storageUuids" json:"storageUuids,omitempty"`
	StorageTypes     []StorageTypeProto `protobuf:"varint,4,rep,name=storageTypes,enum=hadoop.hdfs.StorageTypeProto" json:"storageTypes,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *BlockWithLocationsProto) Reset()                    { *m = BlockWithLocationsProto{} }
func (m *BlockWithLocationsProto) String() string            { return proto.CompactTextString(m) }
func (*BlockWithLocationsProto) ProtoMessage()               {}
func (*BlockWithLocationsProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{31} }

func (m *BlockWithLocationsProto) GetBlock() *BlockProto {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *BlockWithLocationsProto) GetDatanodeUuids() []string {
	if m != nil {
		return m.DatanodeUuids
	}
	return nil
}

func (m *BlockWithLocationsProto) GetStorageUuids() []string {
	if m != nil {
		return m.StorageUuids
	}
	return nil
}

func (m *BlockWithLocationsProto) GetStorageTypes() []StorageTypeProto {
	if m != nil {
		return m.StorageTypes
	}
	return nil
}

// *
// List of block with locations
type BlocksWithLocationsProto struct {
	Blocks           []*BlockWithLocationsProto `protobuf:"bytes,1,rep,name=blocks" json:"blocks,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *BlocksWithLocationsProto) Reset()                    { *m = BlocksWithLocationsProto{} }
func (m *BlocksWithLocationsProto) String() string            { return proto.CompactTextString(m) }
func (*BlocksWithLocationsProto) ProtoMessage()               {}
func (*BlocksWithLocationsProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{32} }

func (m *BlocksWithLocationsProto) GetBlocks() []*BlockWithLocationsProto {
	if m != nil {
		return m.Blocks
	}
	return nil
}

// *
// Editlog information with available transactions
type RemoteEditLogProto struct {
	StartTxId        *uint64 `protobuf:"varint,1,req,name=startTxId" json:"startTxId,omitempty"`
	EndTxId          *uint64 `protobuf:"varint,2,req,name=endTxId" json:"endTxId,omitempty"`
	IsInProgress     *bool   `protobuf:"varint,3,opt,name=isInProgress,def=0" json:"isInProgress,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RemoteEditLogProto) Reset()                    { *m = RemoteEditLogProto{} }
func (m *RemoteEditLogProto) String() string            { return proto.CompactTextString(m) }
func (*RemoteEditLogProto) ProtoMessage()               {}
func (*RemoteEditLogProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{33} }

const Default_RemoteEditLogProto_IsInProgress bool = false

func (m *RemoteEditLogProto) GetStartTxId() uint64 {
	if m != nil && m.StartTxId != nil {
		return *m.StartTxId
	}
	return 0
}

func (m *RemoteEditLogProto) GetEndTxId() uint64 {
	if m != nil && m.EndTxId != nil {
		return *m.EndTxId
	}
	return 0
}

func (m *RemoteEditLogProto) GetIsInProgress() bool {
	if m != nil && m.IsInProgress != nil {
		return *m.IsInProgress
	}
	return Default_RemoteEditLogProto_IsInProgress
}

// *
// Enumeration of editlogs available on a remote namenode
type RemoteEditLogManifestProto struct {
	Logs             []*RemoteEditLogProto `protobuf:"bytes,1,rep,name=logs" json:"logs,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *RemoteEditLogManifestProto) Reset()                    { *m = RemoteEditLogManifestProto{} }
func (m *RemoteEditLogManifestProto) String() string            { return proto.CompactTextString(m) }
func (*RemoteEditLogManifestProto) ProtoMessage()               {}
func (*RemoteEditLogManifestProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{34} }

func (m *RemoteEditLogManifestProto) GetLogs() []*RemoteEditLogProto {
	if m != nil {
		return m.Logs
	}
	return nil
}

// *
// Namespace information that describes namespace on a namenode
type NamespaceInfoProto struct {
	BuildVersion     *string           `protobuf:"bytes,1,req,name=buildVersion" json:"buildVersion,omitempty"`
	Unused           *uint32           `protobuf:"varint,2,req,name=unused" json:"unused,omitempty"`
	BlockPoolID      *string           `protobuf:"bytes,3,req,name=blockPoolID" json:"blockPoolID,omitempty"`
	StorageInfo      *StorageInfoProto `protobuf:"bytes,4,req,name=storageInfo" json:"storageInfo,omitempty"`
	SoftwareVersion  *string           `protobuf:"bytes,5,req,name=softwareVersion" json:"softwareVersion,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *NamespaceInfoProto) Reset()                    { *m = NamespaceInfoProto{} }
func (m *NamespaceInfoProto) String() string            { return proto.CompactTextString(m) }
func (*NamespaceInfoProto) ProtoMessage()               {}
func (*NamespaceInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{35} }

func (m *NamespaceInfoProto) GetBuildVersion() string {
	if m != nil && m.BuildVersion != nil {
		return *m.BuildVersion
	}
	return ""
}

func (m *NamespaceInfoProto) GetUnused() uint32 {
	if m != nil && m.Unused != nil {
		return *m.Unused
	}
	return 0
}

func (m *NamespaceInfoProto) GetBlockPoolID() string {
	if m != nil && m.BlockPoolID != nil {
		return *m.BlockPoolID
	}
	return ""
}

func (m *NamespaceInfoProto) GetStorageInfo() *StorageInfoProto {
	if m != nil {
		return m.StorageInfo
	}
	return nil
}

func (m *NamespaceInfoProto) GetSoftwareVersion() string {
	if m != nil && m.SoftwareVersion != nil {
		return *m.SoftwareVersion
	}
	return ""
}

// *
// Block access token information
type BlockKeyProto struct {
	KeyId            *uint32 `protobuf:"varint,1,req,name=keyId" json:"keyId,omitempty"`
	ExpiryDate       *uint64 `protobuf:"varint,2,req,name=expiryDate" json:"expiryDate,omitempty"`
	KeyBytes         []byte  `protobuf:"bytes,3,opt,name=keyBytes" json:"keyBytes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BlockKeyProto) Reset()                    { *m = BlockKeyProto{} }
func (m *BlockKeyProto) String() string            { return proto.CompactTextString(m) }
func (*BlockKeyProto) ProtoMessage()               {}
func (*BlockKeyProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{36} }

func (m *BlockKeyProto) GetKeyId() uint32 {
	if m != nil && m.KeyId != nil {
		return *m.KeyId
	}
	return 0
}

func (m *BlockKeyProto) GetExpiryDate() uint64 {
	if m != nil && m.ExpiryDate != nil {
		return *m.ExpiryDate
	}
	return 0
}

func (m *BlockKeyProto) GetKeyBytes() []byte {
	if m != nil {
		return m.KeyBytes
	}
	return nil
}

// *
// Current key and set of block keys at the namenode.
type ExportedBlockKeysProto struct {
	IsBlockTokenEnabled *bool            `protobuf:"varint,1,req,name=isBlockTokenEnabled" json:"isBlockTokenEnabled,omitempty"`
	KeyUpdateInterval   *uint64          `protobuf:"varint,2,req,name=keyUpdateInterval" json:"keyUpdateInterval,omitempty"`
	TokenLifeTime       *uint64          `protobuf:"varint,3,req,name=tokenLifeTime" json:"tokenLifeTime,omitempty"`
	CurrentKey          *BlockKeyProto   `protobuf:"bytes,4,req,name=currentKey" json:"currentKey,omitempty"`
	AllKeys             []*BlockKeyProto `protobuf:"bytes,5,rep,name=allKeys" json:"allKeys,omitempty"`
	XXX_unrecognized    []byte           `json:"-"`
}

func (m *ExportedBlockKeysProto) Reset()                    { *m = ExportedBlockKeysProto{} }
func (m *ExportedBlockKeysProto) String() string            { return proto.CompactTextString(m) }
func (*ExportedBlockKeysProto) ProtoMessage()               {}
func (*ExportedBlockKeysProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{37} }

func (m *ExportedBlockKeysProto) GetIsBlockTokenEnabled() bool {
	if m != nil && m.IsBlockTokenEnabled != nil {
		return *m.IsBlockTokenEnabled
	}
	return false
}

func (m *ExportedBlockKeysProto) GetKeyUpdateInterval() uint64 {
	if m != nil && m.KeyUpdateInterval != nil {
		return *m.KeyUpdateInterval
	}
	return 0
}

func (m *ExportedBlockKeysProto) GetTokenLifeTime() uint64 {
	if m != nil && m.TokenLifeTime != nil {
		return *m.TokenLifeTime
	}
	return 0
}

func (m *ExportedBlockKeysProto) GetCurrentKey() *BlockKeyProto {
	if m != nil {
		return m.CurrentKey
	}
	return nil
}

func (m *ExportedBlockKeysProto) GetAllKeys() []*BlockKeyProto {
	if m != nil {
		return m.AllKeys
	}
	return nil
}

// *
// Block that needs to be recovered with at a given location
type RecoveringBlockProto struct {
	NewGenStamp      *uint64            `protobuf:"varint,1,req,name=newGenStamp" json:"newGenStamp,omitempty"`
	Block            *LocatedBlockProto `protobuf:"bytes,2,req,name=block" json:"block,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *RecoveringBlockProto) Reset()                    { *m = RecoveringBlockProto{} }
func (m *RecoveringBlockProto) String() string            { return proto.CompactTextString(m) }
func (*RecoveringBlockProto) ProtoMessage()               {}
func (*RecoveringBlockProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{38} }

func (m *RecoveringBlockProto) GetNewGenStamp() uint64 {
	if m != nil && m.NewGenStamp != nil {
		return *m.NewGenStamp
	}
	return 0
}

func (m *RecoveringBlockProto) GetBlock() *LocatedBlockProto {
	if m != nil {
		return m.Block
	}
	return nil
}

// *
// void request
type VersionRequestProto struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *VersionRequestProto) Reset()                    { *m = VersionRequestProto{} }
func (m *VersionRequestProto) String() string            { return proto.CompactTextString(m) }
func (*VersionRequestProto) ProtoMessage()               {}
func (*VersionRequestProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{39} }

// *
// Version response from namenode.
type VersionResponseProto struct {
	Info             *NamespaceInfoProto `protobuf:"bytes,1,req,name=info" json:"info,omitempty"`
	XXX_unrecognized []byte              `json:"-"`
}

func (m *VersionResponseProto) Reset()                    { *m = VersionResponseProto{} }
func (m *VersionResponseProto) String() string            { return proto.CompactTextString(m) }
func (*VersionResponseProto) ProtoMessage()               {}
func (*VersionResponseProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{40} }

func (m *VersionResponseProto) GetInfo() *NamespaceInfoProto {
	if m != nil {
		return m.Info
	}
	return nil
}

// *
// Information related to a snapshot
// TODO: add more information
type SnapshotInfoProto struct {
	SnapshotName     *string            `protobuf:"bytes,1,req,name=snapshotName" json:"snapshotName,omitempty"`
	SnapshotRoot     *string            `protobuf:"bytes,2,req,name=snapshotRoot" json:"snapshotRoot,omitempty"`
	Permission       *FsPermissionProto `protobuf:"bytes,3,req,name=permission" json:"permission,omitempty"`
	Owner            *string            `protobuf:"bytes,4,req,name=owner" json:"owner,omitempty"`
	Group            *string            `protobuf:"bytes,5,req,name=group" json:"group,omitempty"`
	CreateTime       *string            `protobuf:"bytes,6,req,name=createTime" json:"createTime,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *SnapshotInfoProto) Reset()                    { *m = SnapshotInfoProto{} }
func (m *SnapshotInfoProto) String() string            { return proto.CompactTextString(m) }
func (*SnapshotInfoProto) ProtoMessage()               {}
func (*SnapshotInfoProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{41} }

func (m *SnapshotInfoProto) GetSnapshotName() string {
	if m != nil && m.SnapshotName != nil {
		return *m.SnapshotName
	}
	return ""
}

func (m *SnapshotInfoProto) GetSnapshotRoot() string {
	if m != nil && m.SnapshotRoot != nil {
		return *m.SnapshotRoot
	}
	return ""
}

func (m *SnapshotInfoProto) GetPermission() *FsPermissionProto {
	if m != nil {
		return m.Permission
	}
	return nil
}

func (m *SnapshotInfoProto) GetOwner() string {
	if m != nil && m.Owner != nil {
		return *m.Owner
	}
	return ""
}

func (m *SnapshotInfoProto) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *SnapshotInfoProto) GetCreateTime() string {
	if m != nil && m.CreateTime != nil {
		return *m.CreateTime
	}
	return ""
}

// *
// Rolling upgrade status
type RollingUpgradeStatusProto struct {
	BlockPoolId      *string `protobuf:"bytes,1,req,name=blockPoolId" json:"blockPoolId,omitempty"`
	Finalized        *bool   `protobuf:"varint,2,opt,name=finalized,def=0" json:"finalized,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RollingUpgradeStatusProto) Reset()                    { *m = RollingUpgradeStatusProto{} }
func (m *RollingUpgradeStatusProto) String() string            { return proto.CompactTextString(m) }
func (*RollingUpgradeStatusProto) ProtoMessage()               {}
func (*RollingUpgradeStatusProto) Descriptor() ([]byte, []int) { return fileDescriptorHdfs, []int{42} }

const Default_RollingUpgradeStatusProto_Finalized bool = false

func (m *RollingUpgradeStatusProto) GetBlockPoolId() string {
	if m != nil && m.BlockPoolId != nil {
		return *m.BlockPoolId
	}
	return ""
}

func (m *RollingUpgradeStatusProto) GetFinalized() bool {
	if m != nil && m.Finalized != nil {
		return *m.Finalized
	}
	return Default_RollingUpgradeStatusProto_Finalized
}

func init() {
	proto.RegisterType((*ExtendedBlockProto)(nil), "hadoop.hdfs.ExtendedBlockProto")
	proto.RegisterType((*DatanodeIDProto)(nil), "hadoop.hdfs.DatanodeIDProto")
	proto.RegisterType((*DatanodeLocalInfoProto)(nil), "hadoop.hdfs.DatanodeLocalInfoProto")
	proto.RegisterType((*DatanodeInfosProto)(nil), "hadoop.hdfs.DatanodeInfosProto")
	proto.RegisterType((*DatanodeInfoProto)(nil), "hadoop.hdfs.DatanodeInfoProto")
	proto.RegisterType((*DatanodeStorageProto)(nil), "hadoop.hdfs.DatanodeStorageProto")
	proto.RegisterType((*StorageReportProto)(nil), "hadoop.hdfs.StorageReportProto")
	proto.RegisterType((*ContentSummaryProto)(nil), "hadoop.hdfs.ContentSummaryProto")
	proto.RegisterType((*CorruptFileBlocksProto)(nil), "hadoop.hdfs.CorruptFileBlocksProto")
	proto.RegisterType((*FsPermissionProto)(nil), "hadoop.hdfs.FsPermissionProto")
	proto.RegisterType((*StorageTypesProto)(nil), "hadoop.hdfs.StorageTypesProto")
	proto.RegisterType((*StorageUuidsProto)(nil), "hadoop.hdfs.StorageUuidsProto")
	proto.RegisterType((*LocatedBlockProto)(nil), "hadoop.hdfs.LocatedBlockProto")
	proto.RegisterType((*DataEncryptionKeyProto)(nil), "hadoop.hdfs.DataEncryptionKeyProto")
	proto.RegisterType((*FileEncryptionInfoProto)(nil), "hadoop.hdfs.FileEncryptionInfoProto")
	proto.RegisterType((*PerFileEncryptionInfoProto)(nil), "hadoop.hdfs.PerFileEncryptionInfoProto")
	proto.RegisterType((*ZoneEncryptionInfoProto)(nil), "hadoop.hdfs.ZoneEncryptionInfoProto")
	proto.RegisterType((*LocatedBlocksProto)(nil), "hadoop.hdfs.LocatedBlocksProto")
	proto.RegisterType((*HdfsFileStatusProto)(nil), "hadoop.hdfs.HdfsFileStatusProto")
	proto.RegisterType((*FsServerDefaultsProto)(nil), "hadoop.hdfs.FsServerDefaultsProto")
	proto.RegisterType((*DirectoryListingProto)(nil), "hadoop.hdfs.DirectoryListingProto")
	proto.RegisterType((*SnapshottableDirectoryStatusProto)(nil), "hadoop.hdfs.SnapshottableDirectoryStatusProto")
	proto.RegisterType((*SnapshottableDirectoryListingProto)(nil), "hadoop.hdfs.SnapshottableDirectoryListingProto")
	proto.RegisterType((*SnapshotDiffReportEntryProto)(nil), "hadoop.hdfs.SnapshotDiffReportEntryProto")
	proto.RegisterType((*SnapshotDiffReportProto)(nil), "hadoop.hdfs.SnapshotDiffReportProto")
	proto.RegisterType((*StorageInfoProto)(nil), "hadoop.hdfs.StorageInfoProto")
	proto.RegisterType((*NamenodeRegistrationProto)(nil), "hadoop.hdfs.NamenodeRegistrationProto")
	proto.RegisterType((*CheckpointSignatureProto)(nil), "hadoop.hdfs.CheckpointSignatureProto")
	proto.RegisterType((*NamenodeCommandProto)(nil), "hadoop.hdfs.NamenodeCommandProto")
	proto.RegisterType((*CheckpointCommandProto)(nil), "hadoop.hdfs.CheckpointCommandProto")
	proto.RegisterType((*BlockProto)(nil), "hadoop.hdfs.BlockProto")
	proto.RegisterType((*BlockWithLocationsProto)(nil), "hadoop.hdfs.BlockWithLocationsProto")
	proto.RegisterType((*BlocksWithLocationsProto)(nil), "hadoop.hdfs.BlocksWithLocationsProto")
	proto.RegisterType((*RemoteEditLogProto)(nil), "hadoop.hdfs.RemoteEditLogProto")
	proto.RegisterType((*RemoteEditLogManifestProto)(nil), "hadoop.hdfs.RemoteEditLogManifestProto")
	proto.RegisterType((*NamespaceInfoProto)(nil), "hadoop.hdfs.NamespaceInfoProto")
	proto.RegisterType((*BlockKeyProto)(nil), "hadoop.hdfs.BlockKeyProto")
	proto.RegisterType((*ExportedBlockKeysProto)(nil), "hadoop.hdfs.ExportedBlockKeysProto")
	proto.RegisterType((*RecoveringBlockProto)(nil), "hadoop.hdfs.RecoveringBlockProto")
	proto.RegisterType((*VersionRequestProto)(nil), "hadoop.hdfs.VersionRequestProto")
	proto.RegisterType((*VersionResponseProto)(nil), "hadoop.hdfs.VersionResponseProto")
	proto.RegisterType((*SnapshotInfoProto)(nil), "hadoop.hdfs.SnapshotInfoProto")
	proto.RegisterType((*RollingUpgradeStatusProto)(nil), "hadoop.hdfs.RollingUpgradeStatusProto")
	proto.RegisterEnum("hadoop.hdfs.StorageTypeProto", StorageTypeProto_name, StorageTypeProto_value)
	proto.RegisterEnum("hadoop.hdfs.CipherSuiteProto", CipherSuiteProto_name, CipherSuiteProto_value)
	proto.RegisterEnum("hadoop.hdfs.CryptoProtocolVersionProto", CryptoProtocolVersionProto_name, CryptoProtocolVersionProto_value)
	proto.RegisterEnum("hadoop.hdfs.ChecksumTypeProto", ChecksumTypeProto_name, ChecksumTypeProto_value)
	proto.RegisterEnum("hadoop.hdfs.ReplicaStateProto", ReplicaStateProto_name, ReplicaStateProto_value)
	proto.RegisterEnum("hadoop.hdfs.DatanodeInfoProto_AdminState", DatanodeInfoProto_AdminState_name, DatanodeInfoProto_AdminState_value)
	proto.RegisterEnum("hadoop.hdfs.DatanodeStorageProto_StorageState", DatanodeStorageProto_StorageState_name, DatanodeStorageProto_StorageState_value)
	proto.RegisterEnum("hadoop.hdfs.HdfsFileStatusProto_FileType", HdfsFileStatusProto_FileType_name, HdfsFileStatusProto_FileType_value)
	proto.RegisterEnum("hadoop.hdfs.NamenodeRegistrationProto_NamenodeRoleProto", NamenodeRegistrationProto_NamenodeRoleProto_name, NamenodeRegistrationProto_NamenodeRoleProto_value)
	proto.RegisterEnum("hadoop.hdfs.NamenodeCommandProto_Type", NamenodeCommandProto_Type_name, NamenodeCommandProto_Type_value)
}
func (m *ExtendedBlockProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtendedBlockProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PoolId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("poolId")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.PoolId)))
		i += copy(dAtA[i:], *m.PoolId)
	}
	if m.BlockId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockId")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.BlockId))
	}
	if m.GenerationStamp == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("generationStamp")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.GenerationStamp))
	}
	if m.NumBytes != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.NumBytes))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DatanodeIDProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatanodeIDProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IpAddr == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ipAddr")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.IpAddr)))
		i += copy(dAtA[i:], *m.IpAddr)
	}
	if m.HostName == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("hostName")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.HostName)))
		i += copy(dAtA[i:], *m.HostName)
	}
	if m.DatanodeUuid == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("datanodeUuid")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.DatanodeUuid)))
		i += copy(dAtA[i:], *m.DatanodeUuid)
	}
	if m.XferPort == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("xferPort")
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.XferPort))
	}
	if m.InfoPort == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("infoPort")
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.InfoPort))
	}
	if m.IpcPort == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ipcPort")
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.IpcPort))
	}
	if m.InfoSecurePort != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.InfoSecurePort))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DatanodeLocalInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatanodeLocalInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SoftwareVersion == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("softwareVersion")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.SoftwareVersion)))
		i += copy(dAtA[i:], *m.SoftwareVersion)
	}
	if m.ConfigVersion == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("configVersion")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.ConfigVersion)))
		i += copy(dAtA[i:], *m.ConfigVersion)
	}
	if m.Uptime == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("uptime")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Uptime))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DatanodeInfosProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatanodeInfosProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Datanodes) > 0 {
		for _, msg := range m.Datanodes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DatanodeInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatanodeInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.Id.Size()))
		n1, err := m.Id.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Capacity != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Capacity))
	}
	if m.DfsUsed != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.DfsUsed))
	}
	if m.Remaining != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Remaining))
	}
	if m.BlockPoolUsed != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.BlockPoolUsed))
	}
	if m.LastUpdate != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.LastUpdate))
	}
	if m.XceiverCount != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.XceiverCount))
	}
	if m.Location != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.Location)))
		i += copy(dAtA[i:], *m.Location)
	}
	if m.AdminState != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.AdminState))
	}
	if m.CacheCapacity != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.CacheCapacity))
	}
	if m.CacheUsed != nil {
		dAtA[i] = 0x60
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.CacheUsed))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DatanodeStorageProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatanodeStorageProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StorageUuid == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("storageUuid")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.StorageUuid)))
		i += copy(dAtA[i:], *m.StorageUuid)
	}
	if m.State != nil {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.State))
	}
	if m.StorageType != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.StorageType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StorageReportProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageReportProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StorageUuid == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("storageUuid")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.StorageUuid)))
		i += copy(dAtA[i:], *m.StorageUuid)
	}
	if m.Failed != nil {
		dAtA[i] = 0x10
		i++
		if *m.Failed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Capacity != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Capacity))
	}
	if m.DfsUsed != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.DfsUsed))
	}
	if m.Remaining != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Remaining))
	}
	if m.BlockPoolUsed != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.BlockPoolUsed))
	}
	if m.Storage != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.Storage.Size()))
		n2, err := m.Storage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContentSummaryProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContentSummaryProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Length == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("length")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Length))
	}
	if m.FileCount == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("fileCount")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.FileCount))
	}
	if m.DirectoryCount == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("directoryCount")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.DirectoryCount))
	}
	if m.Quota == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("quota")
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Quota))
	}
	if m.SpaceConsumed == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("spaceConsumed")
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.SpaceConsumed))
	}
	if m.SpaceQuota == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("spaceQuota")
	} else {
		dAtA[i] = 0x30
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.SpaceQuota))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CorruptFileBlocksProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CorruptFileBlocksProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.Cookie == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("cookie")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.Cookie)))
		i += copy(dAtA[i:], *m.Cookie)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FsPermissionProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsPermissionProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Perm == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("perm")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Perm))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StorageTypesProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageTypesProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageTypes) > 0 {
		for _, num := range m.StorageTypes {
			dAtA[i] = 0x8
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StorageUuidsProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageUuidsProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StorageUuids) > 0 {
		for _, s := range m.StorageUuids {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocatedBlockProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocatedBlockProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.B == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("b")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.B.Size()))
		n3, err := m.B.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Offset == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("offset")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Offset))
	}
	if len(m.Locs) > 0 {
		for _, msg := range m.Locs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Corrupt == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("corrupt")
	} else {
		dAtA[i] = 0x20
		i++
		if *m.Corrupt {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BlockToken == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockToken")
	} else {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.BlockToken.Size()))
		n4, err := m.BlockToken.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.IsCached) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.IsCached)))
		for _, b := range m.IsCached {
			if b {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.StorageTypes) > 0 {
		for _, num := range m.StorageTypes {
			dAtA[i] = 0x38
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(num))
		}
	}
	if len(m.StorageIDs) > 0 {
		for _, s := range m.StorageIDs {
			dAtA[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DataEncryptionKeyProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataEncryptionKeyProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("keyId")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.KeyId))
	}
	if m.BlockPoolId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockPoolId")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.BlockPoolId)))
		i += copy(dAtA[i:], *m.BlockPoolId)
	}
	if m.Nonce == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("nonce")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.Nonce)))
		i += copy(dAtA[i:], m.Nonce)
	}
	if m.EncryptionKey == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("encryptionKey")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.EncryptionKey)))
		i += copy(dAtA[i:], m.EncryptionKey)
	}
	if m.ExpiryDate == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("expiryDate")
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.ExpiryDate))
	}
	if m.EncryptionAlgorithm != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.EncryptionAlgorithm)))
		i += copy(dAtA[i:], *m.EncryptionAlgorithm)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FileEncryptionInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileEncryptionInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Suite == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("suite")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Suite))
	}
	if m.CryptoProtocolVersion == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("cryptoProtocolVersion")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.CryptoProtocolVersion))
	}
	if m.Key == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("key")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Iv == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("iv")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.Iv)))
		i += copy(dAtA[i:], m.Iv)
	}
	if m.KeyName == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("keyName")
	} else {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.KeyName)))
		i += copy(dAtA[i:], *m.KeyName)
	}
	if m.EzKeyVersionName == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ezKeyVersionName")
	} else {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.EzKeyVersionName)))
		i += copy(dAtA[i:], *m.EzKeyVersionName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PerFileEncryptionInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerFileEncryptionInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("key")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Iv == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("iv")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.Iv)))
		i += copy(dAtA[i:], m.Iv)
	}
	if m.EzKeyVersionName == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("ezKeyVersionName")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.EzKeyVersionName)))
		i += copy(dAtA[i:], *m.EzKeyVersionName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ZoneEncryptionInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZoneEncryptionInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Suite == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("suite")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Suite))
	}
	if m.CryptoProtocolVersion == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("cryptoProtocolVersion")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.CryptoProtocolVersion))
	}
	if m.KeyName == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("keyName")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.KeyName)))
		i += copy(dAtA[i:], *m.KeyName)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LocatedBlocksProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LocatedBlocksProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FileLength == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("fileLength")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.FileLength))
	}
	if len(m.Blocks) > 0 {
		for _, msg := range m.Blocks {
			dAtA[i] = 0x12
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.UnderConstruction == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("underConstruction")
	} else {
		dAtA[i] = 0x18
		i++
		if *m.UnderConstruction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastBlock != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.LastBlock.Size()))
		n5, err := m.LastBlock.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.IsLastBlockComplete == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("isLastBlockComplete")
	} else {
		dAtA[i] = 0x28
		i++
		if *m.IsLastBlockComplete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FileEncryptionInfo != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.FileEncryptionInfo.Size()))
		n6, err := m.FileEncryptionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HdfsFileStatusProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HdfsFileStatusProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FileType == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("fileType")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.FileType))
	}
	if m.Path == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("path")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	if m.Length == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("length")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Length))
	}
	if m.Permission == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("permission")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.Permission.Size()))
		n7, err := m.Permission.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Owner == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("owner")
	} else {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.Owner)))
		i += copy(dAtA[i:], *m.Owner)
	}
	if m.Group == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("group")
	} else {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.Group)))
		i += copy(dAtA[i:], *m.Group)
	}
	if m.ModificationTime == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("modification_time")
	} else {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.ModificationTime))
	}
	if m.AccessTime == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("access_time")
	} else {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.AccessTime))
	}
	if m.Symlink != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.Symlink)))
		i += copy(dAtA[i:], m.Symlink)
	}
	if m.BlockReplication != nil {
		dAtA[i] = 0x50
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.BlockReplication))
	}
	if m.Blocksize != nil {
		dAtA[i] = 0x58
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Blocksize))
	}
	if m.Locations != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.Locations.Size()))
		n8, err := m.Locations.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.FileId != nil {
		dAtA[i] = 0x68
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.FileId))
	}
	if m.ChildrenNum != nil {
		dAtA[i] = 0x70
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.ChildrenNum))
	}
	if m.FileEncryptionInfo != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.FileEncryptionInfo.Size()))
		n9, err := m.FileEncryptionInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *FsServerDefaultsProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsServerDefaultsProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockSize == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockSize")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.BlockSize))
	}
	if m.BytesPerChecksum == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("bytesPerChecksum")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.BytesPerChecksum))
	}
	if m.WritePacketSize == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("writePacketSize")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.WritePacketSize))
	}
	if m.Replication == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("replication")
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Replication))
	}
	if m.FileBufferSize == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("fileBufferSize")
	} else {
		dAtA[i] = 0x28
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.FileBufferSize))
	}
	if m.EncryptDataTransfer != nil {
		dAtA[i] = 0x30
		i++
		if *m.EncryptDataTransfer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TrashInterval != nil {
		dAtA[i] = 0x38
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.TrashInterval))
	}
	if m.ChecksumType != nil {
		dAtA[i] = 0x40
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.ChecksumType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DirectoryListingProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectoryListingProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PartialListing) > 0 {
		for _, msg := range m.PartialListing {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RemainingEntries == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("remainingEntries")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.RemainingEntries))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SnapshottableDirectoryStatusProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshottableDirectoryStatusProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DirStatus == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("dirStatus")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.DirStatus.Size()))
		n10, err := m.DirStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.SnapshotQuota == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("snapshot_quota")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.SnapshotQuota))
	}
	if m.SnapshotNumber == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("snapshot_number")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.SnapshotNumber))
	}
	if m.ParentFullpath == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("parent_fullpath")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.ParentFullpath)))
		i += copy(dAtA[i:], m.ParentFullpath)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SnapshottableDirectoryListingProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshottableDirectoryListingProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SnapshottableDirListing) > 0 {
		for _, msg := range m.SnapshottableDirListing {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SnapshotDiffReportEntryProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotDiffReportEntryProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fullpath == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("fullpath")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.Fullpath)))
		i += copy(dAtA[i:], m.Fullpath)
	}
	if m.ModificationLabel == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("modificationLabel")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.ModificationLabel)))
		i += copy(dAtA[i:], *m.ModificationLabel)
	}
	if m.TargetPath != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.TargetPath)))
		i += copy(dAtA[i:], m.TargetPath)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SnapshotDiffReportProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotDiffReportProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SnapshotRoot == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("snapshotRoot")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.SnapshotRoot)))
		i += copy(dAtA[i:], *m.SnapshotRoot)
	}
	if m.FromSnapshot == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("fromSnapshot")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.FromSnapshot)))
		i += copy(dAtA[i:], *m.FromSnapshot)
	}
	if m.ToSnapshot == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("toSnapshot")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.ToSnapshot)))
		i += copy(dAtA[i:], *m.ToSnapshot)
	}
	if len(m.DiffReportEntries) > 0 {
		for _, msg := range m.DiffReportEntries {
			dAtA[i] = 0x22
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StorageInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LayoutVersion == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("layoutVersion")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.LayoutVersion))
	}
	if m.NamespceID == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("namespceID")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.NamespceID))
	}
	if m.ClusterID == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("clusterID")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.ClusterID)))
		i += copy(dAtA[i:], *m.ClusterID)
	}
	if m.CTime == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("cTime")
	} else {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.CTime))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NamenodeRegistrationProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamenodeRegistrationProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RpcAddress == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("rpcAddress")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.RpcAddress)))
		i += copy(dAtA[i:], *m.RpcAddress)
	}
	if m.HttpAddress == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("httpAddress")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.HttpAddress)))
		i += copy(dAtA[i:], *m.HttpAddress)
	}
	if m.StorageInfo == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("storageInfo")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.StorageInfo.Size()))
		n11, err := m.StorageInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Role != nil {
		dAtA[i] = 0x20
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Role))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckpointSignatureProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckpointSignatureProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockPoolId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockPoolId")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.BlockPoolId)))
		i += copy(dAtA[i:], *m.BlockPoolId)
	}
	if m.MostRecentCheckpointTxId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("mostRecentCheckpointTxId")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.MostRecentCheckpointTxId))
	}
	if m.CurSegmentTxId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("curSegmentTxId")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.CurSegmentTxId))
	}
	if m.StorageInfo == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("storageInfo")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.StorageInfo.Size()))
		n12, err := m.StorageInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NamenodeCommandProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamenodeCommandProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Action == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("action")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Action))
	}
	if m.Type == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Type))
	}
	if m.CheckpointCmd != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.CheckpointCmd.Size()))
		n13, err := m.CheckpointCmd.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckpointCommandProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckpointCommandProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Signature == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("signature")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.Signature.Size()))
		n14, err := m.Signature.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.NeedToReturnImage == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("needToReturnImage")
	} else {
		dAtA[i] = 0x10
		i++
		if *m.NeedToReturnImage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockId")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.BlockId))
	}
	if m.GenStamp == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("genStamp")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.GenStamp))
	}
	if m.NumBytes != nil {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.NumBytes))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockWithLocationsProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockWithLocationsProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Block == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("block")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.Block.Size()))
		n15, err := m.Block.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if len(m.DatanodeUuids) > 0 {
		for _, s := range m.DatanodeUuids {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.StorageUuids) > 0 {
		for _, s := range m.StorageUuids {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.StorageTypes) > 0 {
		for _, num := range m.StorageTypes {
			dAtA[i] = 0x20
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(num))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlocksWithLocationsProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlocksWithLocationsProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, msg := range m.Blocks {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoteEditLogProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteEditLogProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StartTxId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("startTxId")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.StartTxId))
	}
	if m.EndTxId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("endTxId")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.EndTxId))
	}
	if m.IsInProgress != nil {
		dAtA[i] = 0x18
		i++
		if *m.IsInProgress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoteEditLogManifestProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteEditLogManifestProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for _, msg := range m.Logs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NamespaceInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NamespaceInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuildVersion == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("buildVersion")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.BuildVersion)))
		i += copy(dAtA[i:], *m.BuildVersion)
	}
	if m.Unused == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("unused")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.Unused))
	}
	if m.BlockPoolID == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockPoolID")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.BlockPoolID)))
		i += copy(dAtA[i:], *m.BlockPoolID)
	}
	if m.StorageInfo == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("storageInfo")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.StorageInfo.Size()))
		n16, err := m.StorageInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.SoftwareVersion == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("softwareVersion")
	} else {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.SoftwareVersion)))
		i += copy(dAtA[i:], *m.SoftwareVersion)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BlockKeyProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockKeyProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("keyId")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.KeyId))
	}
	if m.ExpiryDate == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("expiryDate")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.ExpiryDate))
	}
	if m.KeyBytes != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(m.KeyBytes)))
		i += copy(dAtA[i:], m.KeyBytes)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExportedBlockKeysProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportedBlockKeysProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsBlockTokenEnabled == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("isBlockTokenEnabled")
	} else {
		dAtA[i] = 0x8
		i++
		if *m.IsBlockTokenEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeyUpdateInterval == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("keyUpdateInterval")
	} else {
		dAtA[i] = 0x10
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.KeyUpdateInterval))
	}
	if m.TokenLifeTime == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("tokenLifeTime")
	} else {
		dAtA[i] = 0x18
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.TokenLifeTime))
	}
	if m.CurrentKey == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("currentKey")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.CurrentKey.Size()))
		n17, err := m.CurrentKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if len(m.AllKeys) > 0 {
		for _, msg := range m.AllKeys {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintHdfs(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RecoveringBlockProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveringBlockProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NewGenStamp == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("newGenStamp")
	} else {
		dAtA[i] = 0x8
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(*m.NewGenStamp))
	}
	if m.Block == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("block")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.Block.Size()))
		n18, err := m.Block.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VersionRequestProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionRequestProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VersionResponseProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionResponseProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Info == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("info")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.Info.Size()))
		n19, err := m.Info.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SnapshotInfoProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotInfoProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SnapshotName == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("snapshotName")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.SnapshotName)))
		i += copy(dAtA[i:], *m.SnapshotName)
	}
	if m.SnapshotRoot == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("snapshotRoot")
	} else {
		dAtA[i] = 0x12
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.SnapshotRoot)))
		i += copy(dAtA[i:], *m.SnapshotRoot)
	}
	if m.Permission == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("permission")
	} else {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(m.Permission.Size()))
		n20, err := m.Permission.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Owner == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("owner")
	} else {
		dAtA[i] = 0x22
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.Owner)))
		i += copy(dAtA[i:], *m.Owner)
	}
	if m.Group == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("group")
	} else {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.Group)))
		i += copy(dAtA[i:], *m.Group)
	}
	if m.CreateTime == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("createTime")
	} else {
		dAtA[i] = 0x32
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.CreateTime)))
		i += copy(dAtA[i:], *m.CreateTime)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RollingUpgradeStatusProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RollingUpgradeStatusProto) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockPoolId == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockPoolId")
	} else {
		dAtA[i] = 0xa
		i++
		i = encodeVarintHdfs(dAtA, i, uint64(len(*m.BlockPoolId)))
		i += copy(dAtA[i:], *m.BlockPoolId)
	}
	if m.Finalized != nil {
		dAtA[i] = 0x10
		i++
		if *m.Finalized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Hdfs(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Hdfs(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintHdfs(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ExtendedBlockProto) Size() (n int) {
	var l int
	_ = l
	if m.PoolId != nil {
		l = len(*m.PoolId)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.BlockId != nil {
		n += 1 + sovHdfs(uint64(*m.BlockId))
	}
	if m.GenerationStamp != nil {
		n += 1 + sovHdfs(uint64(*m.GenerationStamp))
	}
	if m.NumBytes != nil {
		n += 1 + sovHdfs(uint64(*m.NumBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatanodeIDProto) Size() (n int) {
	var l int
	_ = l
	if m.IpAddr != nil {
		l = len(*m.IpAddr)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.HostName != nil {
		l = len(*m.HostName)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.DatanodeUuid != nil {
		l = len(*m.DatanodeUuid)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XferPort != nil {
		n += 1 + sovHdfs(uint64(*m.XferPort))
	}
	if m.InfoPort != nil {
		n += 1 + sovHdfs(uint64(*m.InfoPort))
	}
	if m.IpcPort != nil {
		n += 1 + sovHdfs(uint64(*m.IpcPort))
	}
	if m.InfoSecurePort != nil {
		n += 1 + sovHdfs(uint64(*m.InfoSecurePort))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatanodeLocalInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.SoftwareVersion != nil {
		l = len(*m.SoftwareVersion)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.ConfigVersion != nil {
		l = len(*m.ConfigVersion)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Uptime != nil {
		n += 1 + sovHdfs(uint64(*m.Uptime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatanodeInfosProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Datanodes) > 0 {
		for _, e := range m.Datanodes {
			l = e.Size()
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatanodeInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Capacity != nil {
		n += 1 + sovHdfs(uint64(*m.Capacity))
	}
	if m.DfsUsed != nil {
		n += 1 + sovHdfs(uint64(*m.DfsUsed))
	}
	if m.Remaining != nil {
		n += 1 + sovHdfs(uint64(*m.Remaining))
	}
	if m.BlockPoolUsed != nil {
		n += 1 + sovHdfs(uint64(*m.BlockPoolUsed))
	}
	if m.LastUpdate != nil {
		n += 1 + sovHdfs(uint64(*m.LastUpdate))
	}
	if m.XceiverCount != nil {
		n += 1 + sovHdfs(uint64(*m.XceiverCount))
	}
	if m.Location != nil {
		l = len(*m.Location)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.AdminState != nil {
		n += 1 + sovHdfs(uint64(*m.AdminState))
	}
	if m.CacheCapacity != nil {
		n += 1 + sovHdfs(uint64(*m.CacheCapacity))
	}
	if m.CacheUsed != nil {
		n += 1 + sovHdfs(uint64(*m.CacheUsed))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatanodeStorageProto) Size() (n int) {
	var l int
	_ = l
	if m.StorageUuid != nil {
		l = len(*m.StorageUuid)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.State != nil {
		n += 1 + sovHdfs(uint64(*m.State))
	}
	if m.StorageType != nil {
		n += 1 + sovHdfs(uint64(*m.StorageType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageReportProto) Size() (n int) {
	var l int
	_ = l
	if m.StorageUuid != nil {
		l = len(*m.StorageUuid)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Failed != nil {
		n += 2
	}
	if m.Capacity != nil {
		n += 1 + sovHdfs(uint64(*m.Capacity))
	}
	if m.DfsUsed != nil {
		n += 1 + sovHdfs(uint64(*m.DfsUsed))
	}
	if m.Remaining != nil {
		n += 1 + sovHdfs(uint64(*m.Remaining))
	}
	if m.BlockPoolUsed != nil {
		n += 1 + sovHdfs(uint64(*m.BlockPoolUsed))
	}
	if m.Storage != nil {
		l = m.Storage.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContentSummaryProto) Size() (n int) {
	var l int
	_ = l
	if m.Length != nil {
		n += 1 + sovHdfs(uint64(*m.Length))
	}
	if m.FileCount != nil {
		n += 1 + sovHdfs(uint64(*m.FileCount))
	}
	if m.DirectoryCount != nil {
		n += 1 + sovHdfs(uint64(*m.DirectoryCount))
	}
	if m.Quota != nil {
		n += 1 + sovHdfs(uint64(*m.Quota))
	}
	if m.SpaceConsumed != nil {
		n += 1 + sovHdfs(uint64(*m.SpaceConsumed))
	}
	if m.SpaceQuota != nil {
		n += 1 + sovHdfs(uint64(*m.SpaceQuota))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CorruptFileBlocksProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, s := range m.Files {
			l = len(s)
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.Cookie != nil {
		l = len(*m.Cookie)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FsPermissionProto) Size() (n int) {
	var l int
	_ = l
	if m.Perm != nil {
		n += 1 + sovHdfs(uint64(*m.Perm))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageTypesProto) Size() (n int) {
	var l int
	_ = l
	if len(m.StorageTypes) > 0 {
		for _, e := range m.StorageTypes {
			n += 1 + sovHdfs(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageUuidsProto) Size() (n int) {
	var l int
	_ = l
	if len(m.StorageUuids) > 0 {
		for _, s := range m.StorageUuids {
			l = len(s)
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocatedBlockProto) Size() (n int) {
	var l int
	_ = l
	if m.B != nil {
		l = m.B.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Offset != nil {
		n += 1 + sovHdfs(uint64(*m.Offset))
	}
	if len(m.Locs) > 0 {
		for _, e := range m.Locs {
			l = e.Size()
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.Corrupt != nil {
		n += 2
	}
	if m.BlockToken != nil {
		l = m.BlockToken.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if len(m.IsCached) > 0 {
		n += 1 + sovHdfs(uint64(len(m.IsCached))) + len(m.IsCached)*1
	}
	if len(m.StorageTypes) > 0 {
		for _, e := range m.StorageTypes {
			n += 1 + sovHdfs(uint64(e))
		}
	}
	if len(m.StorageIDs) > 0 {
		for _, s := range m.StorageIDs {
			l = len(s)
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataEncryptionKeyProto) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != nil {
		n += 1 + sovHdfs(uint64(*m.KeyId))
	}
	if m.BlockPoolId != nil {
		l = len(*m.BlockPoolId)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Nonce != nil {
		l = len(m.Nonce)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.EncryptionKey != nil {
		l = len(m.EncryptionKey)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.ExpiryDate != nil {
		n += 1 + sovHdfs(uint64(*m.ExpiryDate))
	}
	if m.EncryptionAlgorithm != nil {
		l = len(*m.EncryptionAlgorithm)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileEncryptionInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.Suite != nil {
		n += 1 + sovHdfs(uint64(*m.Suite))
	}
	if m.CryptoProtocolVersion != nil {
		n += 1 + sovHdfs(uint64(*m.CryptoProtocolVersion))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Iv != nil {
		l = len(m.Iv)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.KeyName != nil {
		l = len(*m.KeyName)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.EzKeyVersionName != nil {
		l = len(*m.EzKeyVersionName)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PerFileEncryptionInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Iv != nil {
		l = len(m.Iv)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.EzKeyVersionName != nil {
		l = len(*m.EzKeyVersionName)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ZoneEncryptionInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.Suite != nil {
		n += 1 + sovHdfs(uint64(*m.Suite))
	}
	if m.CryptoProtocolVersion != nil {
		n += 1 + sovHdfs(uint64(*m.CryptoProtocolVersion))
	}
	if m.KeyName != nil {
		l = len(*m.KeyName)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LocatedBlocksProto) Size() (n int) {
	var l int
	_ = l
	if m.FileLength != nil {
		n += 1 + sovHdfs(uint64(*m.FileLength))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.UnderConstruction != nil {
		n += 2
	}
	if m.LastBlock != nil {
		l = m.LastBlock.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.IsLastBlockComplete != nil {
		n += 2
	}
	if m.FileEncryptionInfo != nil {
		l = m.FileEncryptionInfo.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HdfsFileStatusProto) Size() (n int) {
	var l int
	_ = l
	if m.FileType != nil {
		n += 1 + sovHdfs(uint64(*m.FileType))
	}
	if m.Path != nil {
		l = len(m.Path)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Length != nil {
		n += 1 + sovHdfs(uint64(*m.Length))
	}
	if m.Permission != nil {
		l = m.Permission.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Group != nil {
		l = len(*m.Group)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.ModificationTime != nil {
		n += 1 + sovHdfs(uint64(*m.ModificationTime))
	}
	if m.AccessTime != nil {
		n += 1 + sovHdfs(uint64(*m.AccessTime))
	}
	if m.Symlink != nil {
		l = len(m.Symlink)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.BlockReplication != nil {
		n += 1 + sovHdfs(uint64(*m.BlockReplication))
	}
	if m.Blocksize != nil {
		n += 1 + sovHdfs(uint64(*m.Blocksize))
	}
	if m.Locations != nil {
		l = m.Locations.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.FileId != nil {
		n += 1 + sovHdfs(uint64(*m.FileId))
	}
	if m.ChildrenNum != nil {
		n += 1 + sovHdfs(uint64(*m.ChildrenNum))
	}
	if m.FileEncryptionInfo != nil {
		l = m.FileEncryptionInfo.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FsServerDefaultsProto) Size() (n int) {
	var l int
	_ = l
	if m.BlockSize != nil {
		n += 1 + sovHdfs(uint64(*m.BlockSize))
	}
	if m.BytesPerChecksum != nil {
		n += 1 + sovHdfs(uint64(*m.BytesPerChecksum))
	}
	if m.WritePacketSize != nil {
		n += 1 + sovHdfs(uint64(*m.WritePacketSize))
	}
	if m.Replication != nil {
		n += 1 + sovHdfs(uint64(*m.Replication))
	}
	if m.FileBufferSize != nil {
		n += 1 + sovHdfs(uint64(*m.FileBufferSize))
	}
	if m.EncryptDataTransfer != nil {
		n += 2
	}
	if m.TrashInterval != nil {
		n += 1 + sovHdfs(uint64(*m.TrashInterval))
	}
	if m.ChecksumType != nil {
		n += 1 + sovHdfs(uint64(*m.ChecksumType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DirectoryListingProto) Size() (n int) {
	var l int
	_ = l
	if len(m.PartialListing) > 0 {
		for _, e := range m.PartialListing {
			l = e.Size()
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.RemainingEntries != nil {
		n += 1 + sovHdfs(uint64(*m.RemainingEntries))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshottableDirectoryStatusProto) Size() (n int) {
	var l int
	_ = l
	if m.DirStatus != nil {
		l = m.DirStatus.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.SnapshotQuota != nil {
		n += 1 + sovHdfs(uint64(*m.SnapshotQuota))
	}
	if m.SnapshotNumber != nil {
		n += 1 + sovHdfs(uint64(*m.SnapshotNumber))
	}
	if m.ParentFullpath != nil {
		l = len(m.ParentFullpath)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshottableDirectoryListingProto) Size() (n int) {
	var l int
	_ = l
	if len(m.SnapshottableDirListing) > 0 {
		for _, e := range m.SnapshottableDirListing {
			l = e.Size()
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotDiffReportEntryProto) Size() (n int) {
	var l int
	_ = l
	if m.Fullpath != nil {
		l = len(m.Fullpath)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.ModificationLabel != nil {
		l = len(*m.ModificationLabel)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.TargetPath != nil {
		l = len(m.TargetPath)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotDiffReportProto) Size() (n int) {
	var l int
	_ = l
	if m.SnapshotRoot != nil {
		l = len(*m.SnapshotRoot)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.FromSnapshot != nil {
		l = len(*m.FromSnapshot)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.ToSnapshot != nil {
		l = len(*m.ToSnapshot)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if len(m.DiffReportEntries) > 0 {
		for _, e := range m.DiffReportEntries {
			l = e.Size()
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.LayoutVersion != nil {
		n += 1 + sovHdfs(uint64(*m.LayoutVersion))
	}
	if m.NamespceID != nil {
		n += 1 + sovHdfs(uint64(*m.NamespceID))
	}
	if m.ClusterID != nil {
		l = len(*m.ClusterID)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.CTime != nil {
		n += 1 + sovHdfs(uint64(*m.CTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NamenodeRegistrationProto) Size() (n int) {
	var l int
	_ = l
	if m.RpcAddress != nil {
		l = len(*m.RpcAddress)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.HttpAddress != nil {
		l = len(*m.HttpAddress)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.StorageInfo != nil {
		l = m.StorageInfo.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Role != nil {
		n += 1 + sovHdfs(uint64(*m.Role))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckpointSignatureProto) Size() (n int) {
	var l int
	_ = l
	if m.BlockPoolId != nil {
		l = len(*m.BlockPoolId)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.MostRecentCheckpointTxId != nil {
		n += 1 + sovHdfs(uint64(*m.MostRecentCheckpointTxId))
	}
	if m.CurSegmentTxId != nil {
		n += 1 + sovHdfs(uint64(*m.CurSegmentTxId))
	}
	if m.StorageInfo != nil {
		l = m.StorageInfo.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NamenodeCommandProto) Size() (n int) {
	var l int
	_ = l
	if m.Action != nil {
		n += 1 + sovHdfs(uint64(*m.Action))
	}
	if m.Type != nil {
		n += 1 + sovHdfs(uint64(*m.Type))
	}
	if m.CheckpointCmd != nil {
		l = m.CheckpointCmd.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckpointCommandProto) Size() (n int) {
	var l int
	_ = l
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.NeedToReturnImage != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockProto) Size() (n int) {
	var l int
	_ = l
	if m.BlockId != nil {
		n += 1 + sovHdfs(uint64(*m.BlockId))
	}
	if m.GenStamp != nil {
		n += 1 + sovHdfs(uint64(*m.GenStamp))
	}
	if m.NumBytes != nil {
		n += 1 + sovHdfs(uint64(*m.NumBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockWithLocationsProto) Size() (n int) {
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if len(m.DatanodeUuids) > 0 {
		for _, s := range m.DatanodeUuids {
			l = len(s)
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if len(m.StorageUuids) > 0 {
		for _, s := range m.StorageUuids {
			l = len(s)
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if len(m.StorageTypes) > 0 {
		for _, e := range m.StorageTypes {
			n += 1 + sovHdfs(uint64(e))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlocksWithLocationsProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteEditLogProto) Size() (n int) {
	var l int
	_ = l
	if m.StartTxId != nil {
		n += 1 + sovHdfs(uint64(*m.StartTxId))
	}
	if m.EndTxId != nil {
		n += 1 + sovHdfs(uint64(*m.EndTxId))
	}
	if m.IsInProgress != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteEditLogManifestProto) Size() (n int) {
	var l int
	_ = l
	if len(m.Logs) > 0 {
		for _, e := range m.Logs {
			l = e.Size()
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NamespaceInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.BuildVersion != nil {
		l = len(*m.BuildVersion)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Unused != nil {
		n += 1 + sovHdfs(uint64(*m.Unused))
	}
	if m.BlockPoolID != nil {
		l = len(*m.BlockPoolID)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.StorageInfo != nil {
		l = m.StorageInfo.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.SoftwareVersion != nil {
		l = len(*m.SoftwareVersion)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockKeyProto) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != nil {
		n += 1 + sovHdfs(uint64(*m.KeyId))
	}
	if m.ExpiryDate != nil {
		n += 1 + sovHdfs(uint64(*m.ExpiryDate))
	}
	if m.KeyBytes != nil {
		l = len(m.KeyBytes)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExportedBlockKeysProto) Size() (n int) {
	var l int
	_ = l
	if m.IsBlockTokenEnabled != nil {
		n += 2
	}
	if m.KeyUpdateInterval != nil {
		n += 1 + sovHdfs(uint64(*m.KeyUpdateInterval))
	}
	if m.TokenLifeTime != nil {
		n += 1 + sovHdfs(uint64(*m.TokenLifeTime))
	}
	if m.CurrentKey != nil {
		l = m.CurrentKey.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if len(m.AllKeys) > 0 {
		for _, e := range m.AllKeys {
			l = e.Size()
			n += 1 + l + sovHdfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecoveringBlockProto) Size() (n int) {
	var l int
	_ = l
	if m.NewGenStamp != nil {
		n += 1 + sovHdfs(uint64(*m.NewGenStamp))
	}
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionRequestProto) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionResponseProto) Size() (n int) {
	var l int
	_ = l
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotInfoProto) Size() (n int) {
	var l int
	_ = l
	if m.SnapshotName != nil {
		l = len(*m.SnapshotName)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.SnapshotRoot != nil {
		l = len(*m.SnapshotRoot)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Permission != nil {
		l = m.Permission.Size()
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Owner != nil {
		l = len(*m.Owner)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Group != nil {
		l = len(*m.Group)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.CreateTime != nil {
		l = len(*m.CreateTime)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RollingUpgradeStatusProto) Size() (n int) {
	var l int
	_ = l
	if m.BlockPoolId != nil {
		l = len(*m.BlockPoolId)
		n += 1 + l + sovHdfs(uint64(l))
	}
	if m.Finalized != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovHdfs(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozHdfs(x uint64) (n int) {
	return sovHdfs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ExtendedBlockProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtendedBlockProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtendedBlockProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.PoolId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerationStamp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GenerationStamp = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumBytes = &v
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("poolId")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockId")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("generationStamp")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatanodeIDProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatanodeIDProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatanodeIDProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.IpAddr = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HostName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatanodeUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.DatanodeUuid = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XferPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XferPort = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InfoPort = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpcPort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IpcPort = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoSecurePort", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InfoSecurePort = &v
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ipAddr")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("hostName")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("datanodeUuid")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("xferPort")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("infoPort")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ipcPort")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatanodeLocalInfoProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatanodeLocalInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatanodeLocalInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SoftwareVersion = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ConfigVersion = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uptime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Uptime = &v
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("softwareVersion")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("configVersion")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("uptime")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatanodeInfosProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatanodeInfosProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatanodeInfosProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datanodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datanodes = append(m.Datanodes, &DatanodeInfoProto{})
			if err := m.Datanodes[len(m.Datanodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatanodeInfoProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatanodeInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatanodeInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &DatanodeIDProto{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Capacity = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DfsUsed", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DfsUsed = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remaining", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remaining = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPoolUsed", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockPoolUsed = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdate", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastUpdate = &v
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field XceiverCount", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XceiverCount = &v
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Location = &s
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminState", wireType)
			}
			var v DatanodeInfoProto_AdminState
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (DatanodeInfoProto_AdminState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminState = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheCapacity", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheCapacity = &v
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheUsed", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CacheUsed = &v
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("id")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatanodeStorageProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatanodeStorageProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatanodeStorageProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StorageUuid = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var v DatanodeStorageProto_StorageState
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (DatanodeStorageProto_StorageState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.State = &v
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageType", wireType)
			}
			var v StorageTypeProto
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (StorageTypeProto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StorageType = &v
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("storageUuid")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageReportProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageReportProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageReportProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StorageUuid = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Failed = &b
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Capacity = &v
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DfsUsed", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DfsUsed = &v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remaining", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Remaining = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPoolUsed", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockPoolUsed = &v
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Storage == nil {
				m.Storage = &DatanodeStorageProto{}
			}
			if err := m.Storage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("storageUuid")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContentSummaryProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContentSummaryProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContentSummaryProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Length = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FileCount = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectoryCount", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DirectoryCount = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quota", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Quota = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceConsumed", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SpaceConsumed = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceQuota", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SpaceQuota = &v
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("length")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("fileCount")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("directoryCount")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("quota")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("spaceConsumed")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("spaceQuota")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorruptFileBlocksProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorruptFileBlocksProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorruptFileBlocksProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Cookie = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("cookie")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsPermissionProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsPermissionProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsPermissionProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Perm", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Perm = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("perm")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageTypesProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageTypesProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageTypesProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageTypes", wireType)
			}
			var v StorageTypeProto
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (StorageTypeProto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StorageTypes = append(m.StorageTypes, v)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageUuidsProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageUuidsProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageUuidsProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageUuids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageUuids = append(m.StorageUuids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocatedBlockProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocatedBlockProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocatedBlockProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field B", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.B == nil {
				m.B = &ExtendedBlockProto{}
			}
			if err := m.B.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Offset = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locs = append(m.Locs, &DatanodeInfoProto{})
			if err := m.Locs[len(m.Locs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corrupt", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Corrupt = &b
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockToken == nil {
				m.BlockToken = &hadoop_common.TokenProto{}
			}
			if err := m.BlockToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 6:
			if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHdfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthHdfs
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowHdfs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IsCached = append(m.IsCached, bool(v != 0))
				}
			} else if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowHdfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IsCached = append(m.IsCached, bool(v != 0))
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCached", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageTypes", wireType)
			}
			var v StorageTypeProto
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (StorageTypeProto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StorageTypes = append(m.StorageTypes, v)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageIDs = append(m.StorageIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("b")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("offset")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("corrupt")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockToken")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataEncryptionKeyProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataEncryptionKeyProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataEncryptionKeyProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPoolId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BlockPoolId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKey = append(m.EncryptionKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionKey == nil {
				m.EncryptionKey = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryDate", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpiryDate = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionAlgorithm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.EncryptionAlgorithm = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("keyId")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockPoolId")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("nonce")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("encryptionKey")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("expiryDate")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileEncryptionInfoProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileEncryptionInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileEncryptionInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suite", wireType)
			}
			var v CipherSuiteProto
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CipherSuiteProto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Suite = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoProtocolVersion", wireType)
			}
			var v CryptoProtocolVersionProto
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CryptoProtocolVersionProto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CryptoProtocolVersion = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iv = append(m.Iv[:0], dAtA[iNdEx:postIndex]...)
			if m.Iv == nil {
				m.Iv = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.KeyName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EzKeyVersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.EzKeyVersionName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("suite")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("cryptoProtocolVersion")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("key")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("iv")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("keyName")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ezKeyVersionName")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerFileEncryptionInfoProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerFileEncryptionInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerFileEncryptionInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iv = append(m.Iv[:0], dAtA[iNdEx:postIndex]...)
			if m.Iv == nil {
				m.Iv = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EzKeyVersionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.EzKeyVersionName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("key")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("iv")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("ezKeyVersionName")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZoneEncryptionInfoProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZoneEncryptionInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZoneEncryptionInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suite", wireType)
			}
			var v CipherSuiteProto
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CipherSuiteProto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Suite = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoProtocolVersion", wireType)
			}
			var v CryptoProtocolVersionProto
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (CryptoProtocolVersionProto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CryptoProtocolVersion = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.KeyName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("suite")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("cryptoProtocolVersion")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("keyName")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LocatedBlocksProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LocatedBlocksProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LocatedBlocksProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileLength", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FileLength = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &LocatedBlockProto{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnderConstruction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.UnderConstruction = &b
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastBlock == nil {
				m.LastBlock = &LocatedBlockProto{}
			}
			if err := m.LastBlock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLastBlockComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsLastBlockComplete = &b
			hasFields[0] |= uint64(0x00000004)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileEncryptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileEncryptionInfo == nil {
				m.FileEncryptionInfo = &FileEncryptionInfoProto{}
			}
			if err := m.FileEncryptionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("fileLength")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("underConstruction")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("isLastBlockComplete")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HdfsFileStatusProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HdfsFileStatusProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HdfsFileStatusProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			var v HdfsFileStatusProto_FileType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (HdfsFileStatusProto_FileType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FileType = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = append(m.Path[:0], dAtA[iNdEx:postIndex]...)
			if m.Path == nil {
				m.Path = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Length = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permission == nil {
				m.Permission = &FsPermissionProto{}
			}
			if err := m.Permission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Group = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ModificationTime = &v
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AccessTime = &v
			hasFields[0] |= uint64(0x00000080)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symlink", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symlink = append(m.Symlink[:0], dAtA[iNdEx:postIndex]...)
			if m.Symlink == nil {
				m.Symlink = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockReplication", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockReplication = &v
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocksize", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Blocksize = &v
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Locations == nil {
				m.Locations = &LocatedBlocksProto{}
			}
			if err := m.Locations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FileId = &v
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildrenNum", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChildrenNum = &v
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileEncryptionInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileEncryptionInfo == nil {
				m.FileEncryptionInfo = &FileEncryptionInfoProto{}
			}
			if err := m.FileEncryptionInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("fileType")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("path")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("length")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("permission")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("owner")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("group")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("modification_time")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("access_time")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsServerDefaultsProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsServerDefaultsProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsServerDefaultsProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSize", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockSize = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesPerChecksum", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BytesPerChecksum = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WritePacketSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WritePacketSize = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replication", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Replication = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileBufferSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FileBufferSize = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptDataTransfer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.EncryptDataTransfer = &b
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrashInterval", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TrashInterval = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumType", wireType)
			}
			var v ChecksumTypeProto
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (ChecksumTypeProto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChecksumType = &v
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockSize")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("bytesPerChecksum")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("writePacketSize")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("replication")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("fileBufferSize")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectoryListingProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectoryListingProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectoryListingProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialListing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartialListing = append(m.PartialListing, &HdfsFileStatusProto{})
			if err := m.PartialListing[len(m.PartialListing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainingEntries", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemainingEntries = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("remainingEntries")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshottableDirectoryStatusProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshottableDirectoryStatusProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshottableDirectoryStatusProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DirStatus == nil {
				m.DirStatus = &HdfsFileStatusProto{}
			}
			if err := m.DirStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotQuota", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SnapshotQuota = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotNumber", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SnapshotNumber = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentFullpath", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentFullpath = append(m.ParentFullpath[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentFullpath == nil {
				m.ParentFullpath = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("dirStatus")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("snapshot_quota")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("snapshot_number")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("parent_fullpath")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshottableDirectoryListingProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshottableDirectoryListingProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshottableDirectoryListingProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshottableDirListing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SnapshottableDirListing = append(m.SnapshottableDirListing, &SnapshottableDirectoryStatusProto{})
			if err := m.SnapshottableDirListing[len(m.SnapshottableDirListing)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotDiffReportEntryProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotDiffReportEntryProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotDiffReportEntryProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fullpath", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fullpath = append(m.Fullpath[:0], dAtA[iNdEx:postIndex]...)
			if m.Fullpath == nil {
				m.Fullpath = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModificationLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModificationLabel = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPath", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetPath = append(m.TargetPath[:0], dAtA[iNdEx:postIndex]...)
			if m.TargetPath == nil {
				m.TargetPath = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("fullpath")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("modificationLabel")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotDiffReportProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotDiffReportProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotDiffReportProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SnapshotRoot = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromSnapshot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FromSnapshot = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToSnapshot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ToSnapshot = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiffReportEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiffReportEntries = append(m.DiffReportEntries, &SnapshotDiffReportEntryProto{})
			if err := m.DiffReportEntries[len(m.DiffReportEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("snapshotRoot")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("fromSnapshot")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("toSnapshot")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageInfoProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LayoutVersion", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LayoutVersion = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NamespceID", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NamespceID = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ClusterID = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CTime = &v
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("layoutVersion")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("namespceID")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("clusterID")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("cTime")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamenodeRegistrationProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamenodeRegistrationProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamenodeRegistrationProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.RpcAddress = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.HttpAddress = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageInfo == nil {
				m.StorageInfo = &StorageInfoProto{}
			}
			if err := m.StorageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var v NamenodeRegistrationProto_NamenodeRoleProto
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (NamenodeRegistrationProto_NamenodeRoleProto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Role = &v
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("rpcAddress")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("httpAddress")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("storageInfo")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckpointSignatureProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckpointSignatureProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckpointSignatureProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPoolId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BlockPoolId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MostRecentCheckpointTxId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MostRecentCheckpointTxId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurSegmentTxId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CurSegmentTxId = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageInfo == nil {
				m.StorageInfo = &StorageInfoProto{}
			}
			if err := m.StorageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockPoolId")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("mostRecentCheckpointTxId")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("curSegmentTxId")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("storageInfo")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamenodeCommandProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamenodeCommandProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamenodeCommandProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Action = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v NamenodeCommandProto_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (NamenodeCommandProto_Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckpointCmd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CheckpointCmd == nil {
				m.CheckpointCmd = &CheckpointCommandProto{}
			}
			if err := m.CheckpointCmd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("action")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("type")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckpointCommandProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckpointCommandProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckpointCommandProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &CheckpointSignatureProto{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedToReturnImage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NeedToReturnImage = &b
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("signature")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("needToReturnImage")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenStamp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GenStamp = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBytes", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NumBytes = &v
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockId")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("genStamp")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockWithLocationsProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockWithLocationsProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockWithLocationsProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockProto{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatanodeUuids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatanodeUuids = append(m.DatanodeUuids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageUuids", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageUuids = append(m.StorageUuids, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageTypes", wireType)
			}
			var v StorageTypeProto
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (StorageTypeProto(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StorageTypes = append(m.StorageTypes, v)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("block")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlocksWithLocationsProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlocksWithLocationsProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlocksWithLocationsProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &BlockWithLocationsProto{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteEditLogProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteEditLogProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteEditLogProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTxId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartTxId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTxId", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndTxId = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInProgress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsInProgress = &b
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("startTxId")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("endTxId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteEditLogManifestProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteEditLogManifestProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteEditLogManifestProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logs = append(m.Logs, &RemoteEditLogProto{})
			if err := m.Logs[len(m.Logs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceInfoProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BuildVersion = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unused", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unused = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPoolID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BlockPoolID = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageInfo == nil {
				m.StorageInfo = &StorageInfoProto{}
			}
			if err := m.StorageInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoftwareVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SoftwareVersion = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("buildVersion")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("unused")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockPoolID")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("storageInfo")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("softwareVersion")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockKeyProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockKeyProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockKeyProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyId = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryDate", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExpiryDate = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyBytes = append(m.KeyBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyBytes == nil {
				m.KeyBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("keyId")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("expiryDate")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportedBlockKeysProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportedBlockKeysProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportedBlockKeysProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBlockTokenEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IsBlockTokenEnabled = &b
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyUpdateInterval", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyUpdateInterval = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenLifeTime", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TokenLifeTime = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentKey == nil {
				m.CurrentKey = &BlockKeyProto{}
			}
			if err := m.CurrentKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllKeys = append(m.AllKeys, &BlockKeyProto{})
			if err := m.AllKeys[len(m.AllKeys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("isBlockTokenEnabled")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("keyUpdateInterval")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("tokenLifeTime")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("currentKey")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveringBlockProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveringBlockProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveringBlockProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewGenStamp", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewGenStamp = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &LocatedBlockProto{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("newGenStamp")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("block")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionRequestProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionRequestProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionRequestProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionResponseProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionResponseProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionResponseProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &NamespaceInfoProto{}
			}
			if err := m.Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("info")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotInfoProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotInfoProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotInfoProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SnapshotName = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotRoot", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.SnapshotRoot = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Permission == nil {
				m.Permission = &FsPermissionProto{}
			}
			if err := m.Permission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Owner = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Group = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.CreateTime = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("snapshotName")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("snapshotRoot")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("permission")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("owner")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("group")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("createTime")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RollingUpgradeStatusProto) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollingUpgradeStatusProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollingUpgradeStatusProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPoolId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHdfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BlockPoolId = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Finalized = &b
		default:
			iNdEx = preIndex
			skippy, err := skipHdfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthHdfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("blockPoolId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHdfs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHdfs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHdfs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthHdfs
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowHdfs
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipHdfs(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthHdfs = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHdfs   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("hdfs.proto", fileDescriptorHdfs) }

var fileDescriptorHdfs = []byte{
	// 3254 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xd4, 0x59, 0xcd, 0x73, 0x1b, 0xc7,
	0x95, 0xd7, 0x0c, 0x40, 0x12, 0x78, 0xfc, 0xd0, 0xb0, 0x45, 0x49, 0x10, 0x2d, 0xd3, 0xf4, 0x58,
	0xb2, 0x28, 0xad, 0xcd, 0xf2, 0xd2, 0x2e, 0x7b, 0x97, 0x6b, 0x7b, 0x8b, 0x04, 0x20, 0x0b, 0x45,
	0x10, 0x80, 0x1b, 0xa4, 0xb4, 0x72, 0xd5, 0x16, 0x6a, 0x38, 0xd3, 0x00, 0x66, 0x39, 0x33, 0x3d,
	0x9e, 0x69, 0x48, 0x82, 0x4f, 0x7b, 0xdc, 0x2a, 0x6f, 0x3e, 0x2e, 0xbe, 0xe5, 0x90, 0x7f, 0x22,
	0x55, 0xf9, 0x0f, 0x92, 0x5b, 0x72, 0xc9, 0x25, 0x95, 0xa4, 0x1c, 0x1f, 0x9c, 0xca, 0x5f, 0x91,
	0x54, 0x7f, 0xcc, 0x60, 0x06, 0x00, 0x45, 0x3b, 0x3e, 0xe5, 0x36, 0xfd, 0xeb, 0xd7, 0xaf, 0xbb,
	0x5f, 0xbf, 0xef, 0x01, 0x18, 0x3a, 0xfd, 0x78, 0x37, 0x8c, 0x28, 0xa3, 0x68, 0x79, 0x68, 0x39,
	0x94, 0x86, 0xbb, 0x1c, 0xda, 0x5c, 0xeb, 0x12, 0x7b, 0x14, 0xb9, 0x6c, 0x2c, 0x27, 0xcd, 0x9f,
	0x68, 0x80, 0xea, 0x2f, 0x18, 0x09, 0x1c, 0xe2, 0x1c, 0x7a, 0xd4, 0x3e, 0xef, 0x88, 0x35, 0x37,
	0x60, 0x31, 0xa4, 0xd4, 0x6b, 0x38, 0x15, 0x6d, 0x5b, 0xdf, 0x29, 0x63, 0x35, 0x42, 0x15, 0x58,
	0x3a, 0xe3, 0x54, 0x0d, 0xa7, 0xa2, 0x6f, 0xeb, 0x3b, 0x45, 0x9c, 0x0c, 0xd1, 0x0e, 0x5c, 0x1d,
	0x90, 0x80, 0x44, 0x16, 0x73, 0x69, 0xd0, 0x65, 0x96, 0x1f, 0x56, 0x0a, 0x82, 0x62, 0x1a, 0x46,
	0xaf, 0x42, 0x29, 0x18, 0xf9, 0x87, 0x63, 0x46, 0xe2, 0x4a, 0x71, 0x5b, 0xdb, 0x29, 0xee, 0x6b,
	0xef, 0xe0, 0x14, 0x32, 0xbf, 0xd5, 0xe0, 0x6a, 0xcd, 0x62, 0x56, 0x40, 0x1d, 0xd2, 0xa8, 0xa5,
	0xc7, 0x71, 0xc3, 0x03, 0xc7, 0x89, 0x92, 0xe3, 0xc8, 0x11, 0xda, 0x84, 0xd2, 0x90, 0xc6, 0xac,
	0x65, 0xf9, 0x44, 0x9c, 0xa7, 0x8c, 0xd3, 0x31, 0x32, 0x61, 0xc5, 0x51, 0x6c, 0x4e, 0x47, 0xae,
	0x23, 0x4e, 0x53, 0xc6, 0x39, 0x8c, 0xaf, 0x7f, 0xd1, 0x27, 0x51, 0x87, 0x46, 0xac, 0x52, 0xdc,
	0xd6, 0x77, 0x56, 0x71, 0x3a, 0xe6, 0x73, 0x6e, 0xd0, 0xa7, 0x62, 0x6e, 0x41, 0xce, 0x25, 0x63,
	0x2e, 0x06, 0x37, 0xb4, 0xc5, 0xd4, 0xa2, 0x98, 0x4a, 0x86, 0xe8, 0x3e, 0xac, 0x71, 0x2a, 0x21,
	0x65, 0x22, 0x08, 0x96, 0xb6, 0xb5, 0x9d, 0x55, 0x7e, 0xc5, 0xa9, 0x09, 0xf3, 0x7f, 0x35, 0xb8,
	0x91, 0x5c, 0xb4, 0x49, 0x6d, 0xcb, 0x6b, 0x70, 0xf6, 0xe2, 0xbe, 0x3b, 0x70, 0x35, 0xa6, 0x7d,
	0xf6, 0xdc, 0x8a, 0xc8, 0x63, 0x12, 0xc5, 0x2e, 0x0d, 0xd4, 0xc5, 0xa7, 0x61, 0x74, 0x07, 0x56,
	0x6d, 0x1a, 0xf4, 0xdd, 0x41, 0x42, 0x27, 0xc5, 0x90, 0x07, 0xb9, 0xfc, 0x46, 0x21, 0x73, 0x7d,
	0xa2, 0xde, 0x44, 0x8d, 0x4c, 0x0c, 0x28, 0x15, 0x75, 0xd0, 0xa7, 0xb1, 0xdc, 0xfd, 0x43, 0x28,
	0x27, 0x52, 0x8a, 0x2b, 0xda, 0x76, 0x61, 0x67, 0x79, 0x6f, 0x6b, 0x37, 0xa3, 0x44, 0xbb, 0xd9,
	0x35, 0x62, 0x09, 0x9e, 0x2c, 0x30, 0xbf, 0x2a, 0xc2, 0xfa, 0x0c, 0x01, 0x7a, 0x0b, 0x74, 0x57,
	0x2a, 0xd3, 0xf2, 0xde, 0xed, 0xf9, 0xcc, 0xe4, 0x5b, 0x63, 0xdd, 0x75, 0xb8, 0x8a, 0xd8, 0x56,
	0x68, 0xd9, 0x2e, 0x1b, 0x57, 0xf4, 0x54, 0x45, 0x12, 0x08, 0xbd, 0x02, 0x4b, 0x4e, 0x3f, 0x3e,
	0x8d, 0x09, 0x7f, 0x55, 0x35, 0x9b, 0x20, 0xe8, 0x35, 0x28, 0x47, 0xc4, 0xb7, 0xdc, 0xc0, 0x0d,
	0x06, 0x13, 0xfd, 0x9a, 0x60, 0xe8, 0x1e, 0xac, 0x0a, 0xa5, 0xed, 0x50, 0xea, 0x09, 0x1e, 0x0b,
	0x09, 0x51, 0x1e, 0x47, 0xaf, 0x03, 0x78, 0x56, 0xcc, 0x4e, 0x43, 0xc7, 0x62, 0xa4, 0xb2, 0x98,
	0x50, 0x65, 0x40, 0x74, 0x17, 0x56, 0x5e, 0xd8, 0xc4, 0x7d, 0x46, 0xa2, 0x2a, 0x1d, 0x05, 0x99,
	0xc7, 0xce, 0xc1, 0x5c, 0x97, 0x3c, 0x6a, 0x0b, 0x1b, 0xa8, 0x94, 0xb6, 0x35, 0xae, 0xa7, 0xc9,
	0x18, 0x7d, 0x0a, 0x60, 0x39, 0xbe, 0xcb, 0x8d, 0x83, 0x91, 0x0a, 0x6c, 0x6b, 0x3b, 0x6b, 0x7b,
	0xf7, 0x5f, 0x2e, 0xee, 0xdd, 0x83, 0x74, 0xc1, 0xfe, 0x62, 0xab, 0x8d, 0x8f, 0x0f, 0x9a, 0x38,
	0xc3, 0x84, 0xdf, 0xd0, 0xb6, 0xec, 0x21, 0xa9, 0x26, 0x32, 0x5c, 0x4e, 0x6f, 0x98, 0xc3, 0xb9,
	0xac, 0x04, 0x20, 0xc4, 0xb0, 0x92, 0xca, 0x2a, 0xc5, 0xcc, 0x06, 0xc0, 0x64, 0x2f, 0x04, 0xa0,
	0x76, 0x33, 0xae, 0xa0, 0x57, 0xe0, 0x66, 0xad, 0x5e, 0x6d, 0x1f, 0x1f, 0x37, 0xba, 0xdd, 0x46,
	0xbb, 0xd5, 0x6b, 0xb4, 0x3a, 0xb8, 0xfd, 0x09, 0xae, 0x77, 0xbb, 0x86, 0x86, 0x10, 0xac, 0x65,
	0x27, 0xeb, 0x35, 0x43, 0x37, 0xff, 0xa6, 0xc1, 0x46, 0x72, 0x93, 0x2e, 0xa3, 0x91, 0x35, 0x20,
	0x52, 0x35, 0xb6, 0x61, 0x39, 0x96, 0x63, 0x61, 0xa7, 0x52, 0xd1, 0xb3, 0x10, 0x6a, 0xc2, 0x42,
	0x2c, 0xa4, 0xa3, 0x0b, 0xe9, 0xec, 0xce, 0x95, 0x4e, 0x96, 0xe7, 0xae, 0x1a, 0xe4, 0x45, 0x24,
	0x99, 0xa0, 0x7a, 0xba, 0xdf, 0xc9, 0x38, 0x24, 0x42, 0x83, 0xd6, 0xf6, 0x5e, 0xcd, 0xf1, 0xec,
	0x4e, 0xe6, 0x05, 0xbf, 0xfd, 0x62, 0xad, 0xd1, 0x3d, 0xc2, 0xd9, 0x75, 0xe6, 0x3b, 0xb0, 0x92,
	0xdd, 0x25, 0x27, 0x9c, 0x0d, 0x30, 0x70, 0xfd, 0xa0, 0xd6, 0x6b, 0xb7, 0x9a, 0x4f, 0x7b, 0xdd,
	0x47, 0x07, 0xb8, 0x5e, 0x33, 0x34, 0xf3, 0x67, 0x3a, 0x20, 0xb5, 0x04, 0x93, 0x90, 0x46, 0x4c,
	0xde, 0xff, 0xce, 0x9c, 0xfb, 0x1f, 0xea, 0x15, 0x2d, 0x2f, 0x83, 0x57, 0x61, 0xb1, 0x6f, 0xb9,
	0x1e, 0x71, 0x84, 0x10, 0x4a, 0xfb, 0x0b, 0x7d, 0xcb, 0x8b, 0x09, 0x56, 0x60, 0xce, 0x62, 0x0a,
	0x2f, 0xb5, 0x98, 0xe2, 0xcb, 0x2d, 0x66, 0xe1, 0xbb, 0x58, 0xcc, 0xe2, 0x05, 0x16, 0xf3, 0x1f,
	0xb0, 0xa4, 0xce, 0x2c, 0x2c, 0x61, 0x79, 0xef, 0xf5, 0x4b, 0x9f, 0x0a, 0x27, 0x2b, 0xcc, 0xdf,
	0x68, 0x70, 0xad, 0x4a, 0x03, 0x46, 0x02, 0xd6, 0x1d, 0xf9, 0xbe, 0x15, 0x8d, 0x53, 0xe7, 0xef,
	0x91, 0x60, 0xc0, 0x86, 0x42, 0x34, 0x45, 0xac, 0x46, 0xe8, 0x36, 0x94, 0xfb, 0xae, 0x47, 0xa4,
	0xe1, 0xc9, 0x68, 0x34, 0x01, 0xd0, 0x9b, 0xb0, 0xe6, 0xb8, 0x11, 0xb1, 0x19, 0x8d, 0xc6, 0x92,
	0x44, 0xba, 0xbe, 0x29, 0x14, 0x6d, 0xc0, 0xc2, 0xe7, 0x23, 0xca, 0x2c, 0xe1, 0xff, 0x8b, 0x58,
	0x0e, 0xb8, 0x5b, 0x8d, 0x43, 0xcb, 0x26, 0x55, 0x1a, 0xc4, 0x23, 0x5f, 0xf8, 0x08, 0x3e, 0x9b,
	0x07, 0xd1, 0x16, 0x80, 0x00, 0x3e, 0x15, 0x0c, 0x16, 0x05, 0x49, 0x06, 0x31, 0x1f, 0xc2, 0x8d,
	0x2a, 0x8d, 0xa2, 0x51, 0xc8, 0x1e, 0xba, 0x1e, 0x11, 0xe1, 0x55, 0xb9, 0xd8, 0x0d, 0x58, 0xe0,
	0x47, 0x95, 0xee, 0xb5, 0x8c, 0xe5, 0x80, 0xdf, 0xd4, 0xa6, 0xf4, 0xdc, 0x4d, 0x82, 0x99, 0x1a,
	0x99, 0xf7, 0x60, 0xfd, 0x61, 0xdc, 0x21, 0x91, 0xef, 0xc6, 0xdc, 0x9d, 0x4b, 0x16, 0x08, 0x8a,
	0x21, 0x89, 0x7c, 0x21, 0x94, 0x55, 0x2c, 0xbe, 0xcd, 0xc7, 0xb0, 0x9e, 0x51, 0x5d, 0xb5, 0xd7,
	0x01, 0xac, 0x64, 0xf4, 0x56, 0x6e, 0x79, 0x99, 0xc2, 0xe3, 0xdc, 0x12, 0xf3, 0x83, 0x94, 0x2f,
	0xd7, 0x45, 0xc5, 0xd7, 0x4c, 0xf9, 0x0a, 0x50, 0x5d, 0x25, 0x87, 0x99, 0xdf, 0xea, 0xb0, 0xce,
	0x63, 0x1b, 0xcb, 0x65, 0x17, 0x6f, 0x83, 0x76, 0xa6, 0x62, 0xc1, 0x6b, 0xb9, 0x63, 0xcc, 0x66,
	0x22, 0x58, 0x3b, 0xe3, 0x62, 0xa1, 0xfd, 0x7e, 0x4c, 0x92, 0x57, 0x56, 0x23, 0xb4, 0x07, 0x45,
	0x8f, 0xda, 0x71, 0xa5, 0xf0, 0x9d, 0x42, 0x94, 0xa0, 0xe5, 0x91, 0xdb, 0x96, 0x4f, 0x22, 0x1e,
	0xbc, 0x84, 0x93, 0x21, 0xfa, 0x77, 0x00, 0xa1, 0xcc, 0x27, 0xf4, 0x9c, 0x04, 0xe2, 0xbd, 0x97,
	0xf7, 0x6e, 0x25, 0x3c, 0x6d, 0xea, 0xfb, 0x34, 0xd8, 0x15, 0x73, 0x92, 0x5d, 0x86, 0x18, 0x6d,
	0x41, 0xc9, 0x8d, 0xab, 0xdc, 0x69, 0x72, 0xd3, 0x28, 0xec, 0x94, 0x0e, 0x75, 0x43, 0xc3, 0x29,
	0x36, 0xf3, 0x02, 0x4b, 0xdf, 0xfb, 0x05, 0x84, 0xaa, 0xc9, 0x71, 0xa3, 0x16, 0x57, 0x4a, 0x42,
	0xd4, 0x19, 0xc4, 0xfc, 0x93, 0x4a, 0x26, 0xea, 0x81, 0x1d, 0x8d, 0x43, 0x1e, 0x58, 0x8e, 0xc8,
	0x38, 0xd5, 0xb5, 0x73, 0x32, 0x56, 0xa9, 0xdc, 0x2a, 0x96, 0x03, 0xee, 0x75, 0x53, 0xdb, 0x55,
	0xd9, 0x5c, 0x19, 0x67, 0x21, 0xbe, 0x2e, 0xa0, 0x81, 0x2d, 0x73, 0x86, 0x15, 0x2c, 0x07, 0xdc,
	0x32, 0x48, 0x76, 0x0f, 0x21, 0xc6, 0x15, 0x9c, 0x07, 0xf9, 0x71, 0xc9, 0x8b, 0xd0, 0x8d, 0xc6,
	0x35, 0xee, 0xb6, 0xa5, 0xf1, 0x64, 0x10, 0xf4, 0x0e, 0x5c, 0x9b, 0x2c, 0x38, 0xf0, 0x06, 0x34,
	0x72, 0xd9, 0xd0, 0x17, 0x7e, 0xa5, 0x8c, 0xe7, 0x4d, 0x99, 0x5f, 0xe9, 0x70, 0x93, 0x5b, 0xd1,
	0xe4, 0x82, 0x93, 0xe4, 0xe2, 0x5d, 0x58, 0x88, 0x47, 0x2e, 0x23, 0xe2, 0x86, 0xd3, 0x82, 0xad,
	0xba, 0xe1, 0x90, 0x44, 0x5d, 0x3e, 0x2f, 0x05, 0x2b, 0x69, 0xd1, 0x7f, 0xc3, 0x75, 0xc1, 0x49,
	0xf2, 0xb0, 0xa9, 0x97, 0xcd, 0xa0, 0xd6, 0xf6, 0xee, 0xe5, 0x99, 0xcc, 0xa3, 0x94, 0xec, 0xe6,
	0x73, 0x41, 0x06, 0x14, 0xce, 0xc9, 0x58, 0xc9, 0x8e, 0x7f, 0xa2, 0x35, 0xd0, 0xdd, 0x67, 0x4a,
	0x5c, 0xba, 0xfb, 0x8c, 0xab, 0xe2, 0x39, 0x19, 0x8b, 0xdc, 0x75, 0x41, 0x48, 0x3f, 0x19, 0xa2,
	0x07, 0x60, 0x90, 0x2f, 0x8e, 0xc8, 0x58, 0xf1, 0x12, 0x24, 0x8b, 0x82, 0x64, 0x06, 0x37, 0xff,
	0x07, 0x36, 0x3b, 0x24, 0xba, 0x48, 0x32, 0xea, 0x14, 0xda, 0xf4, 0x29, 0xf4, 0xf4, 0x14, 0xf3,
	0xf6, 0x2a, 0x5c, 0xb0, 0xd7, 0xaf, 0x34, 0xb8, 0xf9, 0x19, 0x0d, 0xfe, 0x69, 0xde, 0x20, 0x23,
	0xe1, 0x42, 0x4e, 0xc2, 0xe6, 0xd7, 0x3a, 0xa0, 0xac, 0x5f, 0x52, 0x2e, 0x6d, 0x0b, 0x80, 0x7b,
	0xe2, 0x66, 0x36, 0xdc, 0x64, 0x10, 0xf4, 0x3e, 0x2c, 0x0a, 0x0b, 0x89, 0x2b, 0xfa, 0x1c, 0x9f,
	0x33, 0xe3, 0xe8, 0xb0, 0xa2, 0x46, 0x6f, 0xc1, 0xfa, 0x28, 0x70, 0x78, 0x36, 0x18, 0xc4, 0x2c,
	0x1a, 0xd9, 0x22, 0x11, 0x2c, 0x08, 0xff, 0x33, 0x3b, 0xc1, 0xf3, 0x6f, 0x9e, 0x62, 0x0a, 0x3e,
	0x22, 0x5c, 0x5f, 0xbe, 0xd1, 0x64, 0x01, 0x37, 0x2d, 0x37, 0x6e, 0x26, 0xc3, 0x2a, 0xf5, 0x43,
	0x8f, 0x28, 0x1b, 0x2c, 0xe1, 0x79, 0x53, 0xe8, 0x04, 0x50, 0x7f, 0x46, 0x7f, 0x84, 0x2d, 0x2e,
	0xef, 0xdd, 0xc9, 0x6d, 0x7c, 0x81, 0x9a, 0xe1, 0x39, 0xeb, 0xcd, 0x5f, 0x2e, 0xc0, 0xb5, 0x47,
	0x4e, 0x3f, 0xe6, 0x6b, 0x78, 0x86, 0x34, 0x52, 0x32, 0xae, 0x43, 0x89, 0x53, 0x8b, 0xdc, 0x4b,
	0xea, 0x4a, 0x3e, 0xdb, 0x9d, 0xb3, 0x46, 0xec, 0xcb, 0x17, 0xe0, 0x74, 0xa9, 0x08, 0x7f, 0x16,
	0x1b, 0x2a, 0x4d, 0x16, 0xdf, 0x99, 0x4c, 0xa1, 0x90, 0xcb, 0x14, 0x3e, 0x06, 0x08, 0xd3, 0xe8,
	0x29, 0x2c, 0x70, 0x5a, 0xa2, 0x33, 0xe1, 0x15, 0x67, 0x56, 0x70, 0x4f, 0x48, 0x9f, 0x07, 0x24,
	0x52, 0x76, 0x2a, 0x07, 0x1c, 0x1d, 0x44, 0x74, 0x14, 0x2a, 0xd3, 0x94, 0x03, 0xf4, 0x2f, 0xb0,
	0xee, 0x53, 0xc7, 0xed, 0xbb, 0x32, 0xbd, 0xef, 0x89, 0xaa, 0x6b, 0x49, 0x1c, 0xc7, 0xc8, 0x4e,
	0x9c, 0xb8, 0x3e, 0x41, 0xaf, 0xc1, 0xb2, 0x65, 0xdb, 0x24, 0x8e, 0x25, 0x59, 0x49, 0x2a, 0x9c,
	0x84, 0x04, 0x41, 0x05, 0x96, 0xe2, 0xb1, 0xef, 0xb9, 0xc1, 0x79, 0xa5, 0xbc, 0xad, 0xed, 0xac,
	0xe0, 0x64, 0x88, 0x76, 0x61, 0x5d, 0x28, 0x57, 0x2f, 0x22, 0xa1, 0xa7, 0x78, 0x8a, 0xea, 0x41,
	0x94, 0x1f, 0x86, 0x98, 0xc3, 0x93, 0x29, 0x9e, 0xe4, 0x49, 0x65, 0x74, 0xbf, 0x20, 0x93, 0x7a,
	0x60, 0x82, 0xa1, 0x8f, 0xa0, 0x9c, 0xd4, 0x24, 0xb1, 0xa8, 0x05, 0xa6, 0x83, 0xf3, 0xac, 0xbd,
	0xe0, 0xc9, 0x0a, 0x74, 0x0b, 0x16, 0xf9, 0xdb, 0x34, 0x9c, 0xca, 0x6a, 0xc2, 0x5c, 0x01, 0x3c,
	0xc1, 0xb5, 0x87, 0xae, 0xe7, 0x44, 0x24, 0x68, 0x8d, 0xfc, 0xca, 0xda, 0xb6, 0xb6, 0xb3, 0xb0,
	0xaf, 0xbf, 0xfd, 0xaf, 0x38, 0x0b, 0x5f, 0xa0, 0x85, 0x57, 0x7f, 0xa0, 0x16, 0xbe, 0x0b, 0xa5,
	0x44, 0x79, 0x78, 0x86, 0xde, 0xe8, 0xf6, 0x6a, 0x0d, 0x6c, 0x68, 0x68, 0x19, 0x96, 0x1a, 0xdd,
	0xde, 0xc3, 0x46, 0xb3, 0x6e, 0xe8, 0x68, 0x0d, 0xa0, 0xd1, 0xed, 0x75, 0x9f, 0x1e, 0x37, 0x1b,
	0xad, 0x23, 0xa3, 0x60, 0x7e, 0x59, 0x80, 0xeb, 0x0f, 0xe3, 0x2e, 0x89, 0x9e, 0x91, 0xa8, 0x46,
	0xfa, 0xd6, 0xc8, 0x63, 0x4a, 0x79, 0x6f, 0x2b, 0x29, 0x76, 0xb9, 0x14, 0xa5, 0x7f, 0x98, 0x00,
	0xdc, 0x97, 0x9e, 0x8d, 0x19, 0xe1, 0xba, 0x54, 0x1d, 0x12, 0xfb, 0x3c, 0x1e, 0xf9, 0x42, 0x3f,
	0x57, 0xf1, 0x0c, 0xce, 0x4b, 0xfc, 0xe7, 0x11, 0xf7, 0x87, 0x96, 0x7d, 0x4e, 0x98, 0xe0, 0x57,
	0x10, 0xa4, 0xd3, 0x30, 0x8f, 0xd4, 0xd9, 0x37, 0x96, 0x7d, 0x8a, 0x2c, 0xc4, 0x73, 0x5d, 0x7e,
	0xf5, 0xc3, 0x51, 0xbf, 0x4f, 0x22, 0xc1, 0x4a, 0x36, 0x2c, 0xa6, 0x50, 0xf4, 0x41, 0x1a, 0x75,
	0x79, 0xaa, 0x70, 0x12, 0x59, 0x41, 0xdc, 0x27, 0x91, 0xb0, 0xf4, 0xb4, 0xa0, 0x98, 0x47, 0xc1,
	0x0b, 0x00, 0x16, 0x59, 0xf1, 0xb0, 0x11, 0x30, 0x12, 0x3d, 0xb3, 0x3c, 0x91, 0xdd, 0xcb, 0x02,
	0x20, 0x87, 0x23, 0x0c, 0x2b, 0xb6, 0xba, 0xa1, 0x30, 0xf0, 0x92, 0x28, 0xae, 0xf2, 0xb6, 0x56,
	0xcd, 0x10, 0xc8, 0xea, 0x6a, 0xad, 0xfa, 0xa8, 0x5e, 0x3d, 0xea, 0x9e, 0x1e, 0xf7, 0xaa, 0xb8,
	0xfa, 0xee, 0x1e, 0xce, 0xf1, 0x30, 0x7f, 0xa4, 0xc1, 0xf5, 0x5a, 0x92, 0xb4, 0x37, 0xdd, 0x98,
	0xb9, 0xc1, 0x40, 0xbe, 0xc6, 0x23, 0x58, 0x0b, 0xad, 0x88, 0xb9, 0x96, 0xa7, 0x60, 0xd5, 0xad,
	0xd8, 0xbe, 0xcc, 0xa1, 0xe0, 0xa9, 0x75, 0xfc, 0xe5, 0xd2, 0x72, 0xa7, 0x1e, 0xb0, 0xc8, 0x25,
	0x71, 0xf2, 0x72, 0xd3, 0xb8, 0xf9, 0x07, 0x0d, 0x5e, 0xef, 0x06, 0x56, 0x18, 0x0f, 0x29, 0x63,
	0xd6, 0x99, 0x47, 0xd2, 0xc3, 0x65, 0xdd, 0xdc, 0xc7, 0x50, 0x76, 0xdc, 0x48, 0x22, 0x2a, 0xd7,
	0xbd, 0xfc, 0x58, 0x93, 0x25, 0xe8, 0x2e, 0xac, 0xc5, 0x6a, 0x93, 0x9e, 0x2c, 0x50, 0xe4, 0x79,
	0x56, 0x13, 0x54, 0x94, 0x18, 0xe8, 0x1e, 0x5c, 0x4d, 0xc9, 0x82, 0x91, 0x7f, 0x46, 0x22, 0xa5,
	0x46, 0xe9, 0xea, 0x96, 0x40, 0x39, 0x61, 0x68, 0x45, 0x24, 0x60, 0xbd, 0xfe, 0xc8, 0xf3, 0x84,
	0xeb, 0x94, 0xa9, 0xc8, 0x9a, 0x84, 0x1f, 0x2a, 0xd4, 0xfc, 0xb1, 0x06, 0xe6, 0xfc, 0xeb, 0xe5,
	0x64, 0x3f, 0x84, 0x9b, 0xf1, 0x14, 0x55, 0xfe, 0x11, 0xf2, 0x55, 0xfa, 0xa5, 0x02, 0xc3, 0x17,
	0xb1, 0x33, 0xff, 0x4f, 0x83, 0xdb, 0xc9, 0xf2, 0x9a, 0xdb, 0xef, 0xcb, 0xda, 0x99, 0xbf, 0x86,
	0x4a, 0x70, 0x37, 0xa1, 0x94, 0xde, 0x49, 0x66, 0x3a, 0xe9, 0x98, 0x47, 0xde, 0xac, 0xd7, 0x6d,
	0x5a, 0x67, 0xc4, 0x53, 0xc9, 0xee, 0xec, 0x04, 0x8f, 0xff, 0xcc, 0x8a, 0x06, 0x84, 0x75, 0x2c,
	0x11, 0x44, 0xb8, 0xc7, 0xcd, 0x20, 0xe6, 0xef, 0x35, 0xb8, 0x39, 0x7b, 0x94, 0x49, 0x39, 0xa4,
	0xa6, 0x30, 0xa5, 0x4c, 0xf5, 0x31, 0x72, 0x18, 0xa7, 0xe9, 0x47, 0xd4, 0x4f, 0x58, 0xa8, 0x83,
	0xe4, 0x30, 0x71, 0x06, 0x9a, 0x52, 0xc8, 0xbc, 0x25, 0x83, 0xa0, 0x27, 0xb0, 0xee, 0xe4, 0xa4,
	0xe0, 0x8a, 0x3e, 0x2a, 0x17, 0xf9, 0xfd, 0xb9, 0x22, 0x9f, 0x27, 0x33, 0x3c, 0xcb, 0xc3, 0xfc,
	0x7f, 0x0d, 0x0c, 0x55, 0x85, 0x4c, 0xd2, 0xba, 0x3b, 0xb0, 0xea, 0x59, 0x63, 0x3a, 0x62, 0xd9,
	0x3e, 0xe4, 0x2a, 0xce, 0x83, 0xfc, 0xcc, 0x81, 0xe5, 0x93, 0x38, 0xb4, 0x49, 0xa3, 0xa6, 0x14,
	0x35, 0x83, 0x70, 0xb7, 0x69, 0x7b, 0xa3, 0x98, 0x91, 0xa8, 0x51, 0x53, 0x57, 0x9a, 0x00, 0x3c,
	0x90, 0xda, 0x3c, 0xda, 0x25, 0x25, 0xb8, 0x18, 0x98, 0xbf, 0xd0, 0xe1, 0x16, 0xcf, 0xd5, 0x78,
	0x15, 0x87, 0xc9, 0xc0, 0x8d, 0x99, 0x6c, 0x22, 0xa7, 0x99, 0x5a, 0x14, 0xda, 0x07, 0x8e, 0x13,
	0x91, 0x38, 0x56, 0xb2, 0xce, 0x20, 0xdc, 0x69, 0x0e, 0x19, 0x0b, 0x13, 0x02, 0x55, 0xde, 0x64,
	0x20, 0xf4, 0x9f, 0x69, 0xdb, 0x45, 0x04, 0x9a, 0x82, 0x30, 0xd1, 0xb9, 0x35, 0xd9, 0x24, 0xc2,
	0x64, 0x57, 0xa0, 0xc7, 0x50, 0x8c, 0xa8, 0x47, 0x44, 0x86, 0xb6, 0xb6, 0xf7, 0x6f, 0xb9, 0x95,
	0x17, 0x1e, 0x7c, 0x32, 0x43, 0x3d, 0xe5, 0xfd, 0x4a, 0xad, 0x83, 0xe3, 0x7a, 0xab, 0x5d, 0xab,
	0x63, 0xc1, 0xcf, 0xfc, 0x08, 0xd6, 0x67, 0x88, 0xd0, 0x0a, 0xa4, 0x64, 0x86, 0xc6, 0x23, 0xd9,
	0xe1, 0x41, 0xf5, 0xe8, 0xb4, 0x23, 0x83, 0x97, 0x70, 0x9f, 0x9d, 0x76, 0xa3, 0x75, 0x62, 0x14,
	0xcc, 0x3f, 0x6b, 0x50, 0x11, 0x2e, 0x36, 0xa4, 0x6e, 0xc0, 0xba, 0xee, 0x20, 0xb0, 0xd8, 0x28,
	0x9a, 0xf4, 0xda, 0xb2, 0x55, 0x9f, 0x36, 0x5b, 0xf5, 0xed, 0x43, 0xc5, 0xa7, 0x31, 0xc3, 0xc4,
	0x26, 0x01, 0x9b, 0xf0, 0x39, 0x79, 0x91, 0xb6, 0xfc, 0x2f, 0x9c, 0xe7, 0x71, 0xc8, 0x1e, 0x45,
	0x5d, 0x32, 0xf0, 0x89, 0x5a, 0xa1, 0x7a, 0x2e, 0x79, 0x74, 0x5a, 0xf4, 0xc5, 0xef, 0x2b, 0x7a,
	0xf3, 0xaf, 0x1a, 0x6c, 0x24, 0x32, 0xaa, 0x52, 0xdf, 0xb7, 0x02, 0x27, 0xed, 0x15, 0x59, 0x32,
	0xbb, 0x96, 0x7a, 0xaa, 0x46, 0x68, 0x1f, 0x8a, 0x8c, 0xc7, 0x23, 0x59, 0x57, 0xbc, 0x39, 0xf7,
	0xad, 0xb2, 0x8c, 0x76, 0x45, 0xb6, 0x29, 0xd6, 0xa0, 0x06, 0xac, 0xda, 0xe9, 0x3d, 0xab, 0xbe,
	0xec, 0x39, 0x2f, 0xef, 0xbd, 0x31, 0x1b, 0xd4, 0x24, 0x45, 0x86, 0x0d, 0xce, 0xaf, 0x34, 0xf7,
	0xa0, 0x28, 0x32, 0x91, 0x6b, 0x70, 0x75, 0x6a, 0x57, 0xe3, 0x0a, 0xba, 0x0e, 0xeb, 0x82, 0x4b,
	0x27, 0xc3, 0xc5, 0xd0, 0xcc, 0x2f, 0x35, 0xb8, 0x31, 0x9f, 0x3b, 0xaa, 0x42, 0x39, 0x4e, 0xde,
	0x57, 0xc5, 0x98, 0xbb, 0x17, 0x9c, 0x2a, 0xaf, 0x07, 0x78, 0xb2, 0x8e, 0x7b, 0xc8, 0x80, 0x10,
	0xe7, 0x84, 0x62, 0xc2, 0x46, 0x51, 0xd0, 0xf0, 0xad, 0x81, 0x94, 0x53, 0x09, 0xcf, 0x4e, 0x98,
	0x16, 0x40, 0xa6, 0x91, 0x93, 0xf9, 0x1d, 0xa4, 0xe5, 0x7f, 0x07, 0x6d, 0x42, 0x69, 0x40, 0xd4,
	0x7f, 0x20, 0xa9, 0x36, 0xe9, 0x38, 0xf7, 0x03, 0xa8, 0x30, 0xfb, 0x03, 0xe8, 0x77, 0x1a, 0xdc,
	0x14, 0x7b, 0x3c, 0x71, 0xd9, 0xb0, 0x99, 0x24, 0x98, 0x49, 0xe7, 0x68, 0x41, 0xec, 0xa0, 0x6e,
	0x7b, 0x33, 0x77, 0xdb, 0x4c, 0x3d, 0x24, 0xa9, 0xb8, 0xf7, 0xca, 0xfe, 0xef, 0x91, 0x65, 0x5b,
	0x19, 0xe7, 0xc1, 0x99, 0x46, 0x56, 0x61, 0xb6, 0x91, 0x35, 0xd3, 0xc2, 0x29, 0x7e, 0xff, 0x26,
	0xda, 0x7f, 0x41, 0x45, 0xe6, 0xce, 0x73, 0xee, 0xf5, 0x61, 0x5a, 0x58, 0xca, 0xe0, 0x79, 0x67,
	0xf6, 0x62, 0xb3, 0xab, 0x92, 0xf2, 0xd2, 0x7c, 0x0e, 0x08, 0x13, 0x9f, 0x32, 0x52, 0x77, 0x5c,
	0xd6, 0xa4, 0x83, 0x34, 0x57, 0x8d, 0x99, 0x15, 0x49, 0x43, 0x54, 0xb9, 0x6a, 0x0a, 0xf0, 0xa7,
	0x23, 0x81, 0x93, 0x31, 0xeb, 0x64, 0x88, 0xee, 0xc3, 0x8a, 0x1b, 0x37, 0xb8, 0xbb, 0x1a, 0x08,
	0xdf, 0x59, 0xc8, 0xa6, 0x87, 0xb9, 0x29, 0xf3, 0x53, 0xd8, 0xcc, 0x6d, 0x7c, 0x6c, 0x05, 0x6e,
	0x9f, 0xc4, 0x2c, 0x69, 0x09, 0x14, 0x3d, 0x3a, 0x48, 0xae, 0x94, 0x2f, 0x26, 0x66, 0xcf, 0x8b,
	0x05, 0xb1, 0xf9, 0x47, 0x0d, 0x50, 0x4b, 0x44, 0x0e, 0xcb, 0xce, 0xc4, 0x21, 0x13, 0x56, 0xce,
	0x46, 0xae, 0xe7, 0xe4, 0x7f, 0x87, 0xe5, 0x30, 0xf1, 0x97, 0x2b, 0x18, 0xc5, 0xc4, 0x51, 0x11,
	0x48, 0x8d, 0xf2, 0x4e, 0x2f, 0x89, 0x3f, 0x59, 0xe8, 0x07, 0x3b, 0xa4, 0x79, 0x3f, 0xec, 0x16,
	0xe6, 0xfe, 0xb0, 0x33, 0x2d, 0x58, 0x15, 0xcf, 0x79, 0x49, 0x7b, 0x2e, 0xdf, 0x40, 0xd3, 0x67,
	0x1a, 0x68, 0x9b, 0x50, 0x3a, 0x27, 0xe3, 0x89, 0x0d, 0xad, 0xe0, 0x74, 0x6c, 0xfe, 0x54, 0x87,
	0x1b, 0xf5, 0x17, 0x3c, 0xb4, 0xab, 0x6a, 0xed, 0x88, 0x8c, 0x95, 0x9e, 0x89, 0xe6, 0xc0, 0x61,
	0xda, 0xb9, 0xac, 0x07, 0x3c, 0xd7, 0x92, 0x5b, 0x8b, 0xe6, 0xc0, 0xcc, 0x14, 0x77, 0x0f, 0xe7,
	0x64, 0x2c, 0x7f, 0x77, 0xa5, 0xe9, 0xbf, 0x3c, 0xcf, 0xec, 0x04, 0x37, 0x38, 0xc6, 0x57, 0x37,
	0xdd, 0x3e, 0x39, 0x99, 0xfc, 0x6f, 0xcc, 0x83, 0x68, 0x1f, 0xc0, 0x1e, 0x45, 0x3c, 0xeb, 0x4c,
	0x1a, 0x88, 0xcb, 0x7b, 0x9b, 0xb3, 0x1a, 0x9f, 0x88, 0x08, 0x67, 0xa8, 0xd1, 0x7b, 0xb0, 0x64,
	0x79, 0x1e, 0xbf, 0x51, 0x65, 0x41, 0xe8, 0xd5, 0xcb, 0x16, 0x26, 0xa4, 0x66, 0x00, 0x1b, 0x98,
	0xd8, 0xf4, 0x19, 0x89, 0xdc, 0x60, 0x90, 0x71, 0x60, 0xdb, 0xb0, 0x1c, 0x90, 0xe7, 0x9f, 0x24,
	0x9e, 0x4a, 0x5a, 0x49, 0x16, 0x42, 0xef, 0x25, 0x1e, 0x47, 0x9f, 0xd3, 0x36, 0x98, 0x6d, 0xc4,
	0x48, 0x62, 0xf3, 0x3a, 0x5c, 0x53, 0x0f, 0x8e, 0xc9, 0xe7, 0xa3, 0xc4, 0x22, 0xcc, 0x23, 0xd8,
	0x48, 0xe1, 0x38, 0xa4, 0x41, 0x4c, 0x52, 0x4b, 0x71, 0xb9, 0xe2, 0xcd, 0xeb, 0x89, 0xcf, 0x1a,
	0x03, 0x16, 0xc4, 0xe6, 0x5f, 0x34, 0x58, 0x4f, 0x72, 0xbc, 0x9c, 0xa1, 0xa4, 0x99, 0xbf, 0xe5,
	0x93, 0xe9, 0x34, 0x34, 0xf9, 0x35, 0x9e, 0x4b, 0x55, 0xf5, 0x39, 0xa9, 0x6a, 0xbe, 0x67, 0x52,
	0xf8, 0xc7, 0x7b, 0x26, 0xc5, 0xb9, 0x3d, 0x93, 0x85, 0x6c, 0xcf, 0x64, 0x0b, 0xc0, 0x8e, 0x88,
	0xc5, 0xa4, 0xca, 0xc8, 0x76, 0x4a, 0x06, 0x31, 0xcf, 0xe0, 0x16, 0xa6, 0x9e, 0xe7, 0x06, 0x83,
	0xd3, 0x70, 0x10, 0x59, 0x4e, 0xae, 0x9f, 0x74, 0x79, 0x4a, 0xf3, 0x06, 0x94, 0xfb, 0x6e, 0x60,
	0x79, 0xee, 0x17, 0xd3, 0x7f, 0xcf, 0x26, 0xf8, 0x83, 0xbb, 0x69, 0xf2, 0x9b, 0xfa, 0x6f, 0x54,
	0x02, 0xf1, 0xdf, 0xcf, 0xd0, 0xd0, 0x12, 0x14, 0xba, 0xdd, 0x9a, 0xa1, 0x3f, 0x78, 0x1f, 0x8c,
	0xe9, 0x66, 0x26, 0x5a, 0x86, 0xa5, 0xd3, 0xd6, 0x51, 0xab, 0xfd, 0xa4, 0x65, 0x68, 0x3c, 0x8a,
	0x1f, 0xd4, 0xbb, 0xbd, 0xea, 0x09, 0xee, 0xb5, 0xda, 0x9d, 0x83, 0x5a, 0xad, 0xd1, 0xfa, 0xc4,
	0xd0, 0x1f, 0x74, 0x60, 0xf3, 0xe2, 0xfe, 0x25, 0xba, 0x0d, 0x15, 0xc5, 0xa1, 0xd7, 0xc1, 0xed,
	0x93, 0x76, 0xb5, 0xdd, 0xec, 0x3d, 0xae, 0xe3, 0x6e, 0xa3, 0xcd, 0x59, 0x6e, 0x80, 0x51, 0x6f,
	0x55, 0xf1, 0xd3, 0xce, 0x49, 0xa3, 0xdd, 0xea, 0x7d, 0xd6, 0x6e, 0xd5, 0xbb, 0x86, 0xfe, 0xa0,
	0xad, 0xd2, 0x85, 0x6c, 0x25, 0x8d, 0xd6, 0x61, 0x35, 0xad, 0xa5, 0x5b, 0xa7, 0xcd, 0xa6, 0x71,
	0x05, 0x21, 0x98, 0x2a, 0xaf, 0x0d, 0x8d, 0xe7, 0x1f, 0x79, 0xac, 0x6a, 0xe8, 0x0f, 0x9a, 0xb0,
	0xae, 0x1a, 0x46, 0xe2, 0x87, 0xa6, 0x64, 0xb8, 0x0a, 0xe5, 0x87, 0x8d, 0xd6, 0x41, 0xb3, 0xf1,
	0x59, 0xbd, 0x66, 0x5c, 0xe1, 0x72, 0xc0, 0x87, 0x4f, 0xa4, 0x40, 0xf0, 0x13, 0x6c, 0xe8, 0xe2,
	0xe3, 0x14, 0x1b, 0x05, 0x4e, 0x79, 0x52, 0x3f, 0xee, 0xb4, 0xf1, 0x01, 0x7e, 0x6a, 0x14, 0x0f,
	0x0f, 0x7f, 0xfd, 0xcd, 0x96, 0xf6, 0xdb, 0x6f, 0xb6, 0xb4, 0xaf, 0xbf, 0xd9, 0xd2, 0xe0, 0x2e,
	0x8d, 0x06, 0xbb, 0x56, 0x68, 0xd9, 0x43, 0x92, 0xd3, 0xa1, 0x50, 0x49, 0x43, 0x7e, 0x1c, 0x02,
	0x2f, 0x8a, 0xc5, 0xc6, 0xf1, 0xcf, 0x35, 0xed, 0xef, 0x01, 0x00, 0x00, 0xff, 0xff, 0x12, 0xa4,
	0x44, 0xcc, 0xc6, 0x22, 0x00, 0x00,
}
